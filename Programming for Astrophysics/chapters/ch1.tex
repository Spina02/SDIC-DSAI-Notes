\chapter{Introduction}

Operating systems (OS) are the core software that manage a computer's hardware and software resources. Among the most widely used are Microsoft Windows, Apple's macOS, and the open-source Linux. While they differ in many aspects, both macOS and Linux are part of the \bfit{Unix-like} family of operating systems. 

These systems are renowned for their stability, security, and a powerful command-line interface known as the \bfit{shell}. This chapter provides an introduction to the Unix shell, exploring its fundamental role in interacting with the system.

\section{What is a shell?}

The shell is the primary interface between users and the computer's core system. When you type commands in a terminal, the shell interprets these instructions and communicates with the operating system to execute them. It serves as a crucial layer that makes complex system operations accessible through simple text commands.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{assets/shell.png}
    \caption{The Unix Shell}
    \label{fig:shell}
\end{figure}

\begin{definitionblock}[Shell]
    A shell is a program that provides the traditional, text-only user interface for Linux and other UNIX-like operating systems. Its primary function is to read commands that are typed into a console [â€¦] and then execute (i.e., run) them. The term shell derives its name from the fact that it is an outer layer of an operating system. A shell is an interface between the user and the internal parts of the OS (at the very core of which is the kernel). 
    \hfill \textit{\href{http://www.linfo.org/shell.html}{\textasciitilde Linfo}}
\end{definitionblock}

\subsection{File System}

The file system organizes files and directories on a computer. It is a crucial component of the operating system that allows users to store, retrieve, and manage data efficiently. In unix-like systems, the file system is organized in a hierarchical structure.

\vspace{-0.5em}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{assets/filesystem.png}
    \caption{The File System}
    \label{fig:filesystem}
\end{figure}

\vspace{-2em}

\subsubsection{Path}

Each file and directory is identified by a unique path, which is a sequence of directories and files.

\vspace{0.5em}

\begin{center}
    \begin{tabular}{clccl}
        \texttt{/} & Root Directory & & \texttt{$\sim$} & Home Directory \\
        \texttt{.} & Current Directory & & \texttt{..} & Parent Directory \\
        
    \end{tabular}
\end{center}

\begin{exampleblock}[Example of a path]
    \begin{itemize}
        \item a file in the user's Desktop: \plaintt{/home/user/Desktop/file.txt} or \plaintt{\textasciitilde/Desktop/file.txt}
        \item a file in the current directory: \plaintt{./file.txt}
        \item a file in the parent directory: \plaintt{../file.txt}
        \item a file in the home directory: \plaintt{\textasciitilde/file.txt}
    \end{itemize}
\end{exampleblock}

\subsubsection{Navigation Commands}

It is possible to navigate through (and manage files and directories) the file system using the following commands:

\vspace{0.5em}

\begin{minipage}{0.6\textwidth}
    \begin{center}
        \begin{tabular}{c l l}
            \toprule
            \textbf{Command} & \textbf{Description} \\
            \midrule
        \texttt{pwd} & Print Working Directory \\
        \texttt{cd} & Change Directory \\
        \texttt{ls} & List Directory \\
        \texttt{mkdir} & Make Directory \\
        \texttt{rm} & Remove File or Directory \\
        \texttt{cp} & Copy File or Directory \\
        \texttt{mv} & Move File or Directory \\
        \texttt{touch} & Create File \\
        \bottomrule
    \end{tabular}
\end{center}
\end{minipage}
\begin{minipage}{0.35\textwidth}
\centering
\textbf{Recursive Commands:}
\vspace{0.5em}

\texttt{rm}, \texttt{cp} and many other commands can be used recursively into a folder using the flag \texttt{-r} (recursive).
\end{minipage}

\vspace{0.5em}

\begin{tipsblock}[Hidden Files]
    Hidden files are files that are not shown by default when listing the contents of a directory. They are usually marked with a dot (.) at the beginning of their name. e.g. \plaintt{.config}
\end{tipsblock}

\subsubsection{Operators}

Commands can be combined using operators to manipulate input and output streams:

\begin{center}
    \renewcommand{\arraystretch}{1.1}
    \begin{tabular}{c l l}
        \toprule
        \textbf{Operator} & \textbf{Name} & \textbf{Description} \\
        \midrule
        \texttt{>} & output redirection & Redirects standard output to a file, overwriting its contents\\
        \texttt{>>} & append redirection & Redirects standard output, appending it to the end of a file\\
        \texttt{|} & pipe & Passes the output of a command as input to another\\
        \texttt{\&\&} & logical AND & Executes the next command only if the previous one succeeds\\
        \texttt{||} & logical OR & Executes the next command only if the previous one fails\\
        \texttt{;} & separator & Executes commands sequentially, regardless of their outcome\\
        \bottomrule
    \end{tabular}
\end{center}



% spiegare come funzionano le variabili di ambiente (PATH, HOME, USER, etc.)


% searching tools regex (ls, find, locate, grep, etc.) 
% *, ?, [], ^, $ escape (\)

% permissions - chmod, chown, chgrp

% context switch, multiprocessing, fork, exec, source

%config files: bashrc, bash_profile

% head, tail ...




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%55
%   Lecture 2 - Intro to C
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%55

\newpage

\section{Intro to C}

C is a general-purpose programming language created in the 1970s by Dennis Ritchie. Its design gives programmers direct access to the underlying hardware, making it highly efficient and powerful. It is instrumental in implementing operating systems, device drivers, and protocol stacks.

The easiest code we can write in C is:

\begin{codeblock}[language=C]
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
}
\end{codeblock}

\begin{itemize}[noitemsep]
    \item \texttt{\#include <stdio.h>}: is a preprocessor directive.
    \item \texttt{int main()}: is the main function.
    \begin{itemize}[noitemsep]
        \item \texttt{int}: is the return type of the function, if omitted, the function returns an integer.
        \item \texttt{main()}: is the name of the function.
    \end{itemize}
    \item \texttt{printf("...")}: is the function that prints the string \texttt{"Hello, World!"} to the console.
    \item \texttt{\{\}}: is the block of code that contains the statements of the function.
\end{itemize}

\subsection{Compilation}

To compile a C program, use the following command:

\begin{codeblock}[language=bash]
gcc main.c -o main.x
\end{codeblock}

The compiler generates the object code, which is a binary file that contains the machine language translation of the program. The command above actually executes 3 steps:

\begin{enumerate}
    \item \textbf{Preprocessing}:
    
    This step expands the macros and includes the header files. e.g. \texttt{\#include <stdio.h>}
    \begin{codeblock}[language=bash, numbers=none]
gcc -E main.c -o main_preprocessed.c
    \end{codeblock}

    \item \textbf{Compilation}:
    
    The compiler translates the preprocessed code into object code.
    \begin{codeblock}[language=bash, numbers=none]
gcc -c main_preprocessed.c -o main.o
    \end{codeblock}

    During this step, it is possible to set the \texttt{-I} flag to include other directories (useful if the headers are not in the default directory). e.g. \texttt{-I /path/to/include}

    \item \textbf{Linking}: 
    
    The linker combines the object code with the standard library to create an executable.
    \begin{codeblock}[language=bash, numbers=none]
gcc main.o -o main.x
    \end{codeblock}

    The \texttt{-o} flag is used to set the output file name.

    \vspace{0.5em}

    During this step, it is possible to set the \texttt{-L} flag to include other directories (useful if the libraries are not in the default directory). e.g. \texttt{-L /path/to/lib} and to link against external libraries using the \texttt{-l} flag. e.g. \texttt{-lmylib}
    
\end{enumerate}

\subsection{Libraries}

A library is a collection of pre-compiled code, such as functions and data structures, that can be reused across multiple programs. They promote code modularity and prevent developers from having to reimplement common functionalities, such as input/output operations or mathematical calculations. There are two types of libraries:

\begin{itemize}
    \item \texttt{lib\_\_\_.a}: is a static library.
    \item \texttt{lib\_\_\_.so}: is a shared library.
\end{itemize}

The difference between the two is that the static library is linked directly into the executable at compile time, while the shared library is loaded at runtime.

%% types

% int vs float

% floating point: exponent and mantissa

%% loops

% while, do while, for

\subsection{Loops}

% cite break and continue

Loops are used to execute a block of code a specified number of times. There are two main types of loops: the \texttt{while} loop and the \texttt{for} loop.

\subsubsection{While and Do While Loops}

The \texttt{while} loop is used to execute a block of code as long as a specified condition is true.

\begin{codeblock}[language=C]
while (condition) {
    // code
}
\end{codeblock}

If the condition is never met, the block of code is not executed. If we need to execute the block of code at least once, we can use the \texttt{do while} loop.

\begin{codeblock}[language=C]
do {
    // code
} while (condition);
\end{codeblock}

\subsubsection{For Loop}

The \texttt{for} loop is used to execute a block of code a specified number of times.

\begin{codeblock}[language=C]
for (int i = 0; i < 5; i++) {
    // code
}
\end{codeblock}

\subsubsection{Break and Continue}

The \texttt{break} statement is used to exit a loop prematurely. The \texttt{continue} statement is used to skip the rest of the code in a loop and move to the next iteration.

\begin{codeblock}[language=C]
while (1) { // infinite loop (should be avoided)
    // code
    if (condition_1) {
        break; // exit the loop
    }
    else if (condition_2) { 
        continue; // skip the code below and move to the next iteration
    }
}
\end{codeblock}

\subsubsection{Increment and Decrement}

The \texttt{++} and \texttt{--} operators are used to increment and decrement the value of a variable.

There are two types of increment and decrement operators:
\begin{itemize}
    \item \texttt{++i} (\texttt{--i}): is the prefix increment (decrement) operator. The value of the variable is incremented (decremented) before it is used.
    \item \texttt{i++} (\texttt{i--}): is the postfix increment (decrement) operator. The value of the variable is incremented (decremented) after it is used.
\end{itemize}


\subsection{Directives}

Directives are used to control the compilation process. They are used to define constants, macros, and to conditionally compile code.

\subsubsection{Macros}

Macros are used to define values that are not expected to change during the execution of the program. They are defined using the \texttt{\#define} directive.

\begin{codeblock}[language=C]
#define CYCLE 0
\end{codeblock}

\subsubsection{Conditional Compilation}

Conditional compilation is used to compile code only if a certain condition is met. They are defined using the \texttt{\#ifdef}, \texttt{\#ifndef}, \texttt{\#else}, \texttt{\#elif}, and \texttt{\#endif} directives.

\begin{codeblock}[language=C, numbers=none]
#ifdef CYCLE
    // code to compile if CYCLE is defined
#endif
\end{codeblock}

% brief note about pointers (as arrays), cache miss, etc.
%...
%...

\subsection{Functions}

Functions are used to group code into \bfit{routines}: reusable units of code.

\begin{codeblock}[language=]
return-type function-name(parameters declarations, if any) {
    declarations
    statements
    return return-value;
}
\end{codeblock}

Parameters are passed to the function by value, meaning that a copy of the argument is passed to the function. If the argument is a \textit{pointer} (we will see), the function will modify the original argument.

\vspace{0.5em}

It is possible to return only a single value. 
We will see later that it is possible to return a \textit{pointer} or a \textit{struct}, which can be useful to return multiple values from a function.

\vspace{0.5em}

If the return value is not the same specified in the function declaration, the compiler probably won't notice, so be careful.

\subsubsection{Variable scopes}

\begin{itemize}
    \item \textbf{Local scope}:

    Variables declared inside a function are said to have \bfit{local scope}. This means they only exist and are accessible from within that specific function. Once the function finishes its execution, these variables are destroyed. This allows different functions to use the same variable names without causing conflicts.

    \item \textbf{Global scope}:

    Variables declared outside any function are said to have \bfit{global scope}. This means they are accessible from any function in the program.
\end{itemize}

\begin{observationblock}[Variable shadowing]
    If a local variable is declared with the same name as a global variable, the local variable takes precedence within its scope. This is known as \textit{variable shadowing}. The global variable is temporarily hidden, and any reference to that variable name inside the function will refer to the local one. The global variable remains unaffected outside of this scope.

    \begin{codeblock}[language=C]
#include <stdio.h>

int a = 10; // Global variable

void myFunction() {
    int a = 20; // Local variable shadows the global one
    printf("Inside function, a = %d\n", a); // Prints 20
}

int main() {
    printf("Before function call, a = %d\n", a); // Prints 10
    myFunction();
    printf("After function call, a = %d\n", a);  // Prints 10
    return 0;
}
    \end{codeblock}
\end{observationblock}
