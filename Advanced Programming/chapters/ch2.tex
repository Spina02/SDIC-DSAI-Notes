% !TEX root = ../main.tex

\chapter{C++ Basic}

\section{The Birth and Evolution of C++}

Programming languages have always evolved to address the growing complexity of software development. Among these, C++ stands out as a language that bridges the gap between low-level system control and high-level abstraction. It combines the performance of C with the principles of object-oriented programming, enabling developers to tackle complex systems efficiently.

The story of C++ begins with C, a powerful yet simple language created by Dennis Ritchie at Bell Labs in the early 1970s. Its efficiency and portability made it a foundation for system programming. In 1979, Bjarne Stroustrup set out to enhance C by introducing support for object-oriented programming (OOP), creating what he called “C with Classes.” This evolved into C++ in 1983, symbolizing an increment over C, and laid the groundwork for modern software engineering.

Standardization followed in the late 1980s, ensuring compatibility across platforms. Over the years, successive standards like C++11, C++17, and C++20 have introduced features such as smart pointers, lambda expressions, and modules, keeping C++ at the forefront of programming innovation.

\subsection{Key Features of C++}

\begin{itemize}
    \item \textbf{Object-Oriented Programming (OOP)}: 
    C++ introduced core OOP concepts like \textit{classes}, \textit{inheritance}, and \textit{polymorphism}, enabling developers to design modular, reusable, and maintainable software.
    
    \item \textbf{Generic Programming}: 
    The inclusion of \textit{templates} brought the power of generic programming, allowing for flexible and reusable data structures and algorithms. Techniques like \textit{template metaprogramming} extended this capability further.
\end{itemize}

\subsection{Modern Applications and Impact}

Today, C++ is used across diverse fields, including game development, embedded systems, scientific computing, and finance. Its combination of performance and expressiveness makes it a vital tool for building software that demands both efficiency and scalability. 

An active open-source community, including projects like the Boost C++ Libraries, has greatly expanded its capabilities. With ongoing innovations like concepts and modules, C++ continues to adapt to the demands of modern software development, ensuring its relevance for decades to come.

\section{The build process}

\subsection{Compiled vs. Interpreted Languages}

\begin{minipage}[H]{0.43\textwidth}
    C++ is a \textbf{compiled language}, which means that the source code must be translated into machine code before it can be executed. This translation process is performed by a \textbf{compiler}, which reads your source code and generates an executable file that can be run on a computer. 
    \vspace{1em}
    \newline
    In contrast, \textbf{interpreted languages} like Python are executed line by line by an \textbf{interpreter}. The interpreter reads the code, evaluates it, and executes the corresponding instructions without generating a separate executable file.
\end{minipage}%
\hspace{0.02\textwidth}% <-- Aggiunge un piccolo spazio tra le minipage
\begin{minipage}[H]{0.55\textwidth}
    \centering
    \includegraphics[width=0.8\textwidth]{assets/compiled_vs_interpreted.png}
    \captionof{figure}{Compiled vs. Interpreted Languages}
    \label{fig:compiled_vs_interpreted}
\end{minipage}

\subsection{The Build Process}

The build process for a C++ program involves several steps:

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{assets/build_process.png}
    \caption{The Build Process}
    \label{fig:build_process}
\end{figure}

\subsubsection{Preprocessor}

    The preprocessor is the first step in the build process. It processes directives that begin with \texttt{\#} and modifies the source code before it is compiled.
    Common preprocessor directives are:

    \vspace{0.5em}
    
    \begin{itemize}
        \item \texttt{\#include} for including header files;
        \item \texttt{\#define} for defining macros;
        \item \texttt{\#ifdef}, \texttt{\#ifndef}, \texttt{\#else}, \texttt{\#endif} for conditional compilation;
        \item \texttt{\#pragma} for compiler-specific directives.
    \end{itemize}

    \begin{exampleblock}[Preprocessor]
        Original source code:
        
        \begin{codeblock}[language=C++]
#include <iostream>
#define GREETING "Hello, World!"

int main() {
    std::cout << GREETING << std::endl;
    return 0;
}
        \end{codeblock}
        
        Preprocessed source code:
        
        \begin{codeblock}[language=C++]
// Content of <iostream>, simplified for demonstration
namespace std {
    extern ostream cout; 
    extern ostream endl;
}

int main() {
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
        \end{codeblock}
    \end{exampleblock}    

\subsubsection{Compiler}
    
    The \textbf{compiler} translates the preprocessed source code into assembly or machine code. This phase involves multiple steps:
    \begin{enumerate}
        \item \textbf{Lexical Analysis}: Tokenizes the source code into meaningful elements like keywords, identifiers, and operators.
        \item \textbf{Syntax Analysis (Parsing)}: Constructs a syntax tree or abstract syntax tree (AST) to represent the grammatical structure of the code.
        \item \textbf{Semantic Analysis}: Checks for logical consistency, type compatibility, and adherence to language rules.
        \item \textbf{Code Generation}: Converts the AST into assembly or machine code.
        \item \textbf{Optimization}: Enhances the efficiency of the generated code.
        \item \textbf{Output}: Produces object files containing machine code.
    \end{enumerate}
    
The compiler is invoked from the command line using a command like:

\begin{codeblock}[language=bash, numbers=none]
g++ main.cpp -o main.o
\end{codeblock}
    
    Common compiler options include:
    \begin{itemize}
        \item \texttt{-O}: Specify optimization levels (e.g., \texttt{-O2}, \texttt{-O3}).
        \item \texttt{-g}: Include debugging information for tools like \texttt{gdb}.
        \item \texttt{-std}: Specify the C++ standard (e.g., \texttt{-std=c++17}, \texttt{-std=c++20}).
    \end{itemize}

\subsubsection{Linker}
    
    The \textbf{linker} combines object files into a single executable. This step supports modular programming and ensures that all references between different parts of the program are resolved.
    
    The linking process includes:
    \begin{enumerate}
        \item \textbf{Symbol Resolution}: Matches symbols (function, variable names, ...) between object files.
        \item \textbf{Relocation}: Adjusts memory addresses to create a unified memory layout for the program.
        \item \textbf{Output}: Produces an executable file.
        \item \textbf{Linker Errors/Warnings}: Identifies missing symbols or conflicts.
    \end{enumerate}

    The linker is invoked from the command line with a command like:
    
    \begin{codeblock}[language=bash, numbers=none]
g++ main.o helper.o -o my_program
    \end{codeblock}
    
    Linking can be static or dynamic:
    \begin{itemize}
        \item \textbf{Static Linking}: All required libraries are included in the final binary, resulting in a larger file size. Libraries do not need to be present on the target system.
        \item \textbf{Dynamic Linking}: Libraries are referenced at runtime, resulting in a smaller binary. Requires the necessary libraries to be present on the system during execution.
    \end{itemize}

\subsubsection{Loader}
    
    The \textbf{loader} prepares the executable for execution by loading it into memory, handling these steps:
    \begin{enumerate}
        \item \textbf{Memory Allocation}: Reserves memory for the executable and its data.
        \item \textbf{Relocation}: Adjusts memory addresses as necessary to account for the executable's location in memory.
        \item \textbf{Initialization}: Sets up the runtime environment for the program.
        \item \textbf{Execution}: Begins executing the program's entry point (e.g., \texttt{main()} in C++).
    \end{enumerate}
    
    \begin{observationblock}
        Dynamic linking at runtime enhances flexibility by including external libraries only when the program is executed. This approach reduces the initial binary size and allows for library updates without recompiling the application.
    \end{observationblock}

\subsection{The Build toolchain in practice}

\subsubsection{Preprocessor and Compiler}

The build process starts with the \textbf{preprocessor} (\texttt{cpp}) and the \textbf{compiler} (\texttt{g++}, \texttt{clang++}):
\begin{itemize}
    \item \textbf{Preprocessor}: Handles directives like \texttt{\#include}, performs macro substitution, and prepares code.
    \item \textbf{Compiler}: Translates preprocessed code into machine-readable object files.
    \end{itemize}

These steps are often combined when using a compiler command like \texttt{g++} or \texttt{clang++}.


    For a project with three files (\plaintt{module.hpp}, \plaintt{module.cpp}, \plaintt{main.cpp}), the following commands illustrate preprocessing and compilation:
    
    \begin{codeblock}[language=bash, numbers=none]
# Preprocessor step.
g++ -E module.cpp -I/path/to/include/dir -o module_preprocessed.cpp
g++ -E main.cpp -I/path/to/include/dir -o main_preprocessed.cpp

# Compilation step.
g++ -c module_preprocessed.cpp -o module.o
g++ -c main_preprocessed.cpp -o main.o
    \end{codeblock}

    \begin{observationblock}
        \begin{itemize}
            \item \plaintt{-E}: Preprocess only.
            \item \plaintt{-c}: Compile only (generate object file).
            \item \plaintt{-I}: Include other directories (useful if the headers are not in the default directory).
        \end{itemize}
    \end{observationblock}


\subsubsection{Linker}

The \textbf{linker} (\texttt{ld}) combines object files into an executable program by resolving external references between them. It also links external libraries if required.

\vspace{-0.3em}

\begin{codeblock}[language=bash, numbers=none]
g++ module.o main.o -o my_program
\end{codeblock}


\textbf{Linking Against Libraries}

To link against external libraries, use the \texttt{-l} flag for library names (without the \texttt{lib} prefix or file extension) and the \texttt{-L} flag to specify the library directory:

\vspace{-0.3em}

\begin{codeblock}[language=bash, numbers=none]
g++ module.o main.o -o my_program -lmy_lib -L/path/to/my/lib
\end{codeblock}

The \texttt{-lmy\_lib} flag links to the \texttt{libmy\_lib.so} (dynamic) or \texttt{libmy\_lib.a} (static) file in the specified directory.

\subsubsection{Preprocessor, Compiler, Linker: Simplified Workflow}

For small projects with few dependencies, a single command can handle preprocessing, compilation, and linking:

\vspace{-0.3em}

\begin{codeblock}[language=bash, numbers=none]
g++ mod1.cpp mod2.cpp main.cpp -I/path/to/include/dir -o my_program
\end{codeblock}

\begin{warningblock}[Compiler Behavior]
Different compilers (e.g., GCC, Clang) may produce varying behaviors, warnings, or errors. For an example of such differences, see this comparison on \href{https://godbolt.org/z/1M83E4sYE}{GodBolt}.
\end{warningblock}

\subsubsection{Loader}

The \textbf{loader} is responsible for preparing the executable program for execution:
\begin{itemize}
    \item Allocates memory for code and data sections.
    \item Resolves addresses for dynamically linked libraries.
    \item Starts program execution.
\end{itemize}

\textbf{Running an Executable}

\begin{codeblock}[language=bash, numbers=none]
./my_program
\end{codeblock}

\textbf{Dynamic Libraries and \texttt{LD\_LIBRARY\_PATH}}

When linking against external dynamic libraries, the loader uses the environment variable \texttt{LD\_LIBRARY\_PATH} to locate them. Ensure the required library paths are included:

\begin{codeblock}[language=bash, numbers=none]
export LD_LIBRARY_PATH+=:/path/to/my/lib
./my_program
\end{codeblock}

\section{Structure of a Basic C++ Program}

\subsection{Overview of Program Structure}

A typical C++ program is composed of a collection of functions. Every C++ program must include the \texttt{main()} function, which serves as the entry point. Additional functions can be defined as needed, and their statements are enclosed in curly braces \texttt{\{\}}. Statements are executed sequentially unless control structures like loops or conditionals are applied.

\begin{exampleblock}[Basic Program Structure]
    \begin{codeblock}[language=C++]
#include <iostream>

int main() { // Entry point of the program.
    std::cout << "Hello, world!" << std::endl;
    return 0; // Indicates successful execution.
}
\end{codeblock}
\end{exampleblock}

Let's break down the key components of this basic C++ program:

\begin{itemize}
    \item \plaintt{\#include <iostream>}: Includes the Input/Output stream library.
    \item \plaintt{int main()}: The entry point function.
    \item \plaintt{std::cout}: Standard output stream for printing to the console.
    \item \plaintt{<<}: Stream insertion operator.
    \item \plaintt{"Hello, world!"}: The string to print.
    \item \plaintt{<< std::endl}: Outputs a newline character and flushes the stream.
    \item \plaintt{return 0;}: Indicates successful program termination.
\end{itemize}

\subsubsection{How to Compile and Run}

After writing your C++ program, use the GNU C++ compiler (g++) to create an executable:

\vspace{-0.5em}

\begin{codeblock}[language=bash, numbers=none]
g++ hello_world.cpp -o hello_world
\end{codeblock}

\vspace{-0.5em}

Execute the compiled program from the terminal, optionally passing command-line arguments:

\vspace{-0.5em}

\begin{codeblock}[language=bash, numbers=none]
./hello_world [arg1] [arg2] ... [argN]
\end{codeblock}

\vspace{-0.5em}

Verify the program's execution status by examining its exit code (0 typically indicates success):

\vspace{-0.5em}

\begin{codeblock}[language=bash, numbers=none]
echo $?
\end{codeblock}

\subsection{C++ as a Strongly Typed Language}

C++ enforces strict type checking during compilation. Variables must be declared with a specific type, ensuring type safety and reducing runtime errors. 

\vspace{0.5em}

It provides various built-in "\textbf{Fundamental Types}" to handle data of different kinds and sizes. These types include integers, floating-point numbers, characters, Booleans, and more.

\begin{table}[H]
    \centering
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Data Type} & \textbf{Size (Bytes)} & \textbf{\plaintt{<cstdint>}} \\ \hline
        \plaintt{bool} & 1 &  \\ \hline
        \plaintt{char} & 1 &  \\ \hline
        \plaintt{signed char} & 1 & \plaintt{int8\_t} \\ \hline
        \plaintt{unsigned char} & 1 & \plaintt{uint8\_t} \\ \hline
        \plaintt{short} & 2 & \plaintt{int16\_t} \\ \hline
        \plaintt{unsigned short} & 2 & \plaintt{uint16\_t} \\ \hline
        \plaintt{int} & 4 & \plaintt{int32\_t} \\ \hline
        \plaintt{unsigned int} & 4 & \plaintt{uint32\_t} \\ \hline
        \plaintt{long int} & 4 or 8 & \plaintt{int32\_t} or \plaintt{int64\_t} \\ \hline
        \plaintt{long unsigned int} & 4 or 8 & \plaintt{uint32\_t} or \plaintt{uint64\_t} \\ \hline
        \plaintt{long long int} & 8 & \plaintt{int64\_t} \\ \hline
        \plaintt{long long unsigned int} & 8 & \plaintt{uint64\_t} \\ \hline
        \plaintt{float} & 4 &  \\ \hline
        \plaintt{double} & 8 &  \\ \hline
    \end{tabular}
    \vspace{-0.3em}
    \caption{Sizes of Fundamental Types in C++}
\end{table}

\vspace{-1em}

\begin{exampleblock}[Strong Typing in C++]
    \begin{codeblock}[language=C++]
int x = 5;
char ch = 'A';
float f = 3.14;

x = 1.6;             // Legal, but truncated to 1.
f = "a string";      // Illegal.

unsigned int y{3.0}; // Uniform initialization: illegal.
    \end{codeblock}
\end{exampleblock}

C++ supports several \textbf{integer types} with varying sizes and value ranges. Common types include \texttt{int}, \texttt{short}, \texttt{long}, and \texttt{long long}.

\vspace{-0.5em}

\begin{codeblock}[language=C++, numbers=none]    
short age = 30;                             // 2 bytes
int population = 75000;                     // 4 bytes 
long long large_number = 123456789012345;   // 8 bytes
\end{codeblock}

\textbf{Floating-point types} represent real numbers. These include \texttt{float}, \texttt{double}, and \texttt{long double}. They are ideal for representing decimal values.

\vspace{-0.5em}

\begin{codeblock}[language=C++, numbers=none]
float pi = 3.14;        // 4 bytes
double e = 2.71828;     // 8 bytes
\end{codeblock}

\subsubsection{Floating-Point Arithmetic}

Floating-point numbers in C++ are represented using the format $\pm f \cdot 2^e$, where:
\begin{itemize}
    \item $f$: the \textit{significand} or \textit{mantissa}, representing the precision of the number.
    \item $e$: the \textit{exponent}, determining the scale of the number.
    \item $2$: the \textit{base}, as floating-point numbers are typically stored in binary form.
\end{itemize}

This representation enables efficient handling of very large or very small values but comes with certain limitations, such as rounding errors.

\begin{exampleblock}[Floating-Point Arithmetic]
    \begin{codeblock}[language=C++]
double a = 0.1, b = 0.2, c = 0.3;

if (a + b == c) { // Unsafe comparison.
    // Due to precision limitations, this might not hold true.
}

if (std::abs((a + b) - c) < 1e-9) {
    // Use a tolerance for safe comparison.
}
    \end{codeblock}
    \begin{codeblock}[language=C++]
double epsilon = 1.0;
        
while (1.0 + epsilon != 1.0) {
    epsilon /= 2.0; // Finding machine epsilon.
}
    \end{codeblock}
\end{exampleblock}

\textbf{Normalized Numbers}: In normalized form, the most significant bit of the significand is always 1, which ensures efficient use of available precision and avoids redundant representations.

\textbf{IEEE 754 Standard}: The IEEE 754 Standard defines how floating-point numbers are represented and manipulated. It specifies:

\begin{itemize}
    \item Standardized formats for \texttt{float}, \texttt{double}, and \texttt{long double}.
    \item Rounding rules to maintain accuracy.
    \item Special values such as \texttt{NaN} (Not-a-Number) and infinity for handling exceptional cases.
\end{itemize}


\subsubsection{Characters and Strings}

Characters in C++ are represented using the \texttt{char} type, while strings are sequences of characters represented by the \texttt{std::string} class.

\vspace{-0.5em}

\begin{codeblock}[language=C++, numbers=none]
char letter = 'A'; // Single character.
std::string name = "Alice"; // String of characters.
std::string greeting = "Hello, " + name + "!"; // Concatenation.
\end{codeblock}

\subsubsection{Boolean Types}

C++ provides a built-in \texttt{bool} type for logical values. A \texttt{bool} variable can hold one of two values, \texttt{true} or \texttt{false}, useful for conditional statements and logical operations. 

\vspace{-0.5em}

\begin{codeblock}[language=C++, numbers=none]
bool flag = true;
if (flag) {
    std::cout << "Flag is true" << std::endl;
}
\end{codeblock}
Numbers are implicitly converted to \texttt{bool}: 0 is \texttt{false}; non-zero (including negatives) is \texttt{true}.

\vspace{-0.5em}

\begin{codeblock}[language=C++, numbers=none]
if (0)    // false
if (42)   // true
\end{codeblock}

\subsection{\texttt{NULL}, \texttt{NaN}}

\subsubsection{NULL}

\texttt{NULL} is used to represent a null pointer or an invalid memory address. Its representation depends on the system and context:

\begin{itemize}
    \item In C/C++, \texttt{NULL} is typically defined as \texttt{0} or \texttt{((void*)0)}. Since C++11, the \texttt{nullptr} keyword is preferred for null pointers, as it provides better type safety and clarity.
    \item In memory, a null pointer is often represented by a sequence of \textbf{all-zero bits}. (e.g. 32-bit system: \texttt{0x00000000}; 64-bit system: \texttt{0x0000000000000000})
\end{itemize}


\begin{exampleblock}[Representation of NULL]
    \begin{codeblock}[language=C++]
int* ptr = nullptr; // ptr points to memory address 0x00000000
if (ptr == nullptr) {
    std::cout << "Pointer is null" << std::endl;
}
    \end{codeblock}
\end{exampleblock}

\subsubsection{NaN}

\texttt{NaN} (Not a Number) is a special value used in floating-point arithmetic to represent undefined or unrepresentable results. Its representation is defined by the \textbf{IEEE 754 floating-point standard}:

\begin{itemize}
    \item A \texttt{NaN} value is represented by an \textbf{exponent filled with 1s} and a \textbf{non-zero significand}.
    \item There are two types of \texttt{NaN}, \texttt{qNaN} and \texttt{sNaN}:
    \begin{itemize}
        \item \textbf{Quiet NaN}: It is used for undefined or unrepresentable results. It has a leading \texttt{1} in the significand.
        \item \textbf{Signaling NaN}: It is used to trigger exceptions in certain operations. It has a leading \texttt{0} in the significand.
    \end{itemize}
\end{itemize}
    
\begin{exampleblock}[Representation of NaN]
    \begin{codeblock}[language=C++]
double x = 0.0 / 0.0; // Creates NaN
if (isnan(x)) {
    std::cout << "x is NaN" << std::endl;
}
    \end{codeblock}
\end{exampleblock}

\subsubsection{Key Differences}

It is important to distinguish between \texttt{NULL} and \texttt{NaN}, as they serve different purposes and have distinct representations. The table below highlights the key differences between the two:

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
    \hline
    \hfill \textbf{Feature} \hfill & \hfill \textbf{\plaintt{NULL}} \hfill & \hfill \textbf{\plaintt{NaN}} \hfill \\ \hline
    Purpose & Represents a null pointer & Represents an undefined floating-point value \\ \hline
    Data Type & Used with pointers & Used with floating-point numbers \\ \hline
    Representation & All-zero bits & Exponent filled with 1s and non-zero significand \\ \hline
    Usage & Pointer comparison & Floating-point arithmetic \\ \hline
\end{tabular}
\caption{Key Differences Between \texttt{NULL} and \texttt{NaN}}
\end{table}

\subsection{Initialization and Aliases}

Initialization assigns an initial value to a variable at the time of declaration. C++ supports several initialization methods: direct, copy, and uniform initialization.

\begin{codeblock}[language=C++, numbers=none]
int x = 42;     // Direct initialization.
int y(30);      // Constructor-style initialization.
int z{15};      // Uniform initialization (preferred).
\end{codeblock}

\textbf{Type Aliases} can create alternative names for existing types using \texttt{using} or \texttt{typedef}.

\begin{codeblock}[language=C++, numbers=none]
using integer = int;    // Alias for int.
typedef float distance; // Alias for float.
\end{codeblock}

\subsection{The \plaintt{auto} Keyword and Type conversion}

The \texttt{auto} keyword allows the compiler to deduce the type of a variable based on its initialization value. This is useful for simplifying code and avoiding verbose type declarations.

\begin{codeblock}[language=C++, numbers=none]
auto a{42};         // int.
auto b{12L};        // long.
auto c{5.0F};       // float.
auto d{10.0};       // double.
auto e{false};      // bool.
auto f{"string"};   // char[7].
\end{codeblock}

\begin{tipsblock}[Best Practices]
    \begin{itemize}
        \item Use \plaintt{auto} for complex types or when the exact type is unimportant.
        \item Avoid \plaintt{auto} for publicly visible variables or ambiguous initializations.
    \end{itemize}
\end{tipsblock}

C++ supports \textbf{implicit and explicit type conversions} to convert between different data types. Implicit conversions are performed automatically by the compiler, while explicit conversions require manual intervention.

\begin{itemize}
    \item \textbf{Implicit conversion}:
    \begin{codeblock}[language=C++, numbers=none]
int x = 10;
double y = x; // int to double (implicit).
    \end{codeblock}
    \item \textbf{Explicit conversion}:
    \begin{codeblock}[language=C++, numbers=none]
double z = 3.14;
int w = static_cast<int>(z); // double to int (explicit).
    \end{codeblock}
\end{itemize}

\subsection{Variables, Pointers, References and Arrays}

\textbf{Variables} represent named memory locations for storing data, while \textbf{pointers} store memory addresses and enable direct manipulation of memory. Additionally, \textbf{references} provide an alias for an existing variable, ensuring efficient and safe access without the risks associated with pointer arithmetic. \textbf{Arrays}, on the other hand, are collections of elements stored contiguously in memory, offering a structured way to manage multiple related data items while maintaining type safety.

\subsubsection{Variables}

We have already seen what variables are and how they are initialized. More formally, variables are named memory locations that store data of a specific type. They must be declared before use and can be modified during program execution.

\begin{codeblock}[language=C++]
int x = 5;              // Declaration and initialization.
x = 10;                 // Modification.

int y;                  // Declaration.
y = 20;                 // Initialization after declaration.

const double a = 3.7;   // Constant variable.
// a = 5;               // Error: cannot modify a constant.
// double x = 3.14;     // Error: redeclaration of 'x'.
\end{codeblock}

\subsubsection{Pointers}

Pointers store memory addresses, allowing for direct manipulation and efficient access to memory. They enable operations like pointer arithmetic, dynamic memory management, and low-level data handling, making them a powerful tool in C++. Pointers are declared using the \texttt{*} symbol and are typically initialized with the address of a variable using the \texttt{\&} operator.

\begin{codeblock}[language=C++]
int number = 42;
int* pointer = &number; // Pointer to 'number'.

// Dynamic allocation.
int* dynamicVar = new int;
*dynamicVar = 5;

// Deallocation.
delete dynamicVar;
dynamicVar = nullptr;
\end{codeblock}

\begin{warningblock}[Common Pointer Pitfalls]

    Accessing memory out-of-bounds may result in unpredictable behavior and even cause program crashes. Failing to deallocate dynamically allocated memory properly can lead to memory leaks, while dereferencing null or dangling pointers may trigger undefined behavior.

    \begin{codeblock}[language=C++]
    int* arr = new int[5];
    // Incorrect loop: accesses out-of-bound index.
    for (int i = 0; i <= 5; ++i) {
        arr[i] = i;
    }
    std::cout << arr[10] << std::endl;  // Undefined behavior.
    // delete[] arr;  // Missing deletion leads to a memory leak.
\end{codeblock}

    Always perform bounds checking, match every allocation with the appropriate deallocation, and validate pointers before use.

\end{warningblock}

\subsubsection{References}

References in C++ serve as aliases for existing variables, allowing you to access them using an alternative name. They are declared with the \texttt{\&} symbol and must be initialized at the time of declaration. Unlike pointers, references cannot be made to refer to a different variable once set; this helps to ensure safer and more predictable data access.

\begin{codeblock}[language=C++]
int a = 10;
int& ref = a; // 'ref' is an alias for 'a'.
ref = 20;     // Modifies 'a'.

int b = 10;
ref = b;      // 'ref' still refers to 'a', which is now 10.
ref = 5;      // Now, 'a' becomes 5 while 'b' remains 10.
\end{codeblock}

Arrays are collections of elements of the same type stored contiguously in memory. In modern C++, it is recommended to use container classes such as \texttt{std::array} for fixed-size arrays or \texttt{std::vector} for dynamic arrays. 

\begin{codeblock}[language=C++]
int numbers[5]; // Static array.
numbers[0] = 1;

int* dynamicArray = new int[5];
for (int i = 0; i < 5; ++i) {
    dynamicArray[i] = 2 * i;
}
delete[] dynamicArray;
\end{codeblock}

\section{Memory Management}

In computer programming, memory is divided into two main regions: the \textbf{stack} and the \textbf{heap}. These regions serve different purposes and are managed differently.

\begin{exampleblock}[Working with Variables and Pointers]
    \begin{codeblock}[language=C++]
int stack_var = 10;          // Stack variable
int* stack_ptr = &value;     // Pointer to stack variable

int* heap_var = new int(25); // Pointer to heap-allocated variable
*heap_var = 30;              // Modify heap variable through pointer

// Cleanup
delete heap_var;             // Deallocate heap memory
heap_var = nullptr;          // Reset pointer.
    \end{codeblock}
\end{exampleblock}

\subsection{Stack Memory}

The \textbf{stack} is used for \textbf{static memory allocation}, where memory is allocated and deallocated in a last-in, first-out (LIFO) order. 

\subsubsection{Key Characteristics of Stack Memory}
\begin{itemize}
    \item \textbf{Purpose}: Used for storing local variables, function parameters, and return addresses.
    \item \textbf{Management}: Memory allocation and deallocation are handled automatically by the compiler.
    \item \textbf{Speed}: Accessing the stack is very fast because it uses a simple pointer-based mechanism (the stack pointer).
    \item \textbf{Size}: The stack has a limited size, which is determined at the start of the program. If the stack exceeds its size, a \textbf{stack overflow} occurs.
    \item \textbf{Lifetime}: Memory is automatically freed when the function or block that allocated it exits.
    \item \textbf{Fragmentation-Free}: The stack does not suffer from fragmentation because memory is always allocated and freed in a strict order.
\end{itemize}

\begin{exampleblock}[Stack Memory Example]
    \begin{codeblock}[language=C++]
void foo() {
    int x = 10; // 'x' is allocated on the stack
    // Memory for 'x' is automatically freed when 'foo' exits
}
    \end{codeblock}
\end{exampleblock}

\subsection{Heap Memory}

The \textbf{heap} is used for \textbf{dynamic allocation}, where memory is allocated and deallocated in any order. This region is more flexible than the stack but requires careful management to avoid memory leaks and fragmentation.

\subsubsection{Key Characteristics of Heap Memory}
\begin{itemize}
    \item \textbf{Purpose}: Used for dynamically allocated data (e.g., arrays, objects, or data structures whose size is not known at compile time).
    \item \textbf{Management}: Memory allocation and deallocation are managed manually by the programmer (e.g., using \texttt{malloc}/\texttt{free} in C or \texttt{new}/\texttt{delete} in C++).
    \item \textbf{Speed}: Accessing the heap is slower than the stack as it involves complex memory management.
    \item \textbf{Size}: The heap is much larger than the stack and can grow dynamically as needed (limited only by the system's available memory).
    \item \textbf{Lifetime}: Memory remains allocated until it is explicitly freed by the programmer. If not freed, it leads to \textbf{memory leaks}.
    \item \textbf{Fragmentation}: The heap can suffer from fragmentation over time, as memory is allocated and freed in arbitrary order.
\end{itemize}

\begin{exampleblock}[Heap Memory Example]
    \begin{codeblock}[language=C++]
void bar() {
    int* ptr = new int(20); // points to memory on the heap
    // Memory for 'ptr' must be explicitly freed
    delete ptr; // Free the memory to avoid a memory leak
}
    \end{codeblock}
\end{exampleblock}

\subsection{Key Differences Between Stack and Heap}

\vspace{-1em}

\begin{table}[H]
    \centering
    \small
\begin{tabular}{|l|l|l|}
    % \small
    \hline
    \hfill \textbf{Feature} \hfill & \hfill \textbf{Stack Memory} \hfill & \hfill \textbf{Heap Memory} \hfill \\ \hline
    Purpose & Static memory allocation & Dynamic memory allocation \\ \hline
    Management & Automatic (compiler-managed) & Manual (programmer-managed) \\ \hline
    Speed & Very fast & Slower \\ \hline
    Size & Limited (predefined size) & Large (limited by system memory) \\ \hline
    Lifetime & Automatically freed when scope ends & Must be explicitly freed \\ \hline
    Fragmentation & No fragmentation & Can suffer from fragmentation \\ \hline
    Usage & Local variables, function parameters & Dynamically allocated data \\ \hline
\end{tabular}
\end{table}

\vspace{-0.5em}

\subsubsection{When to Use Stack vs. Heap}

\vspace{-0.5em}

\begin{itemize}
    \item \textbf{Use the Stack}:
    \begin{itemize}
        \item For small, short-lived data (e.g., local variables, function parameters).
        \item When the size of the data is known at compile time.
        \item When you want fast and automatic memory management.
    \end{itemize}
    \item \textbf{Use the Heap}:
    \begin{itemize}
        \item For large or dynamically sized data (e.g., arrays, objects).
        \item When the lifetime of the data extends beyond the current scope.
        \item When you need flexibility in memory allocation and deallocation.
    \end{itemize}
\end{itemize}

\subsubsection{Lifetime and Scope}

\textbf{Stack Variables} are declared locally within functions or blocks, are stored on the stack and are accessible directly.
\textbf{Heap Variables} require pointers for access and explicit deallocation.
The \textbf{lifetime} of a variable refers to the duration it exists in memory, while its \textbf{scope} defines where it is accessible in code.

\begin{itemize}
    \item \textbf{Stack Variables:}
    \begin{itemize}
        \item Limited to the scope of their defining function or block.
        \item Automatically deallocated when the scope ends.
    \end{itemize}

    \item \textbf{Heap Variables:}
    \begin{itemize}
        \item Persist beyond their defining scope until explicitly deallocated.
        \item Risk memory leaks if not deallocated properly.
    \end{itemize}
\end{itemize}

\begin{codeblock}[language=C++]
void foo() {                      //        Lifetime:
    int stack_var = 5;            // ends with the function.
    int* heap_var = new int(10);  // persists until delete.

    delete heap_var;      // Deallocate heap memory.
    heap_var = nullptr;   // Reset pointer.
}
\end{codeblock}

\begin{tipsblock}[Best Practices for Memory Management]
    \begin{itemize}
        \item Use stack memory for small, short-lived variables.
        \item Use heap memory for large or long-lived data.
        \item Always match \plaintt{new} with \plaintt{delete} and \plaintt{new[]} with \plaintt{delete[]}.
        \item Prefer modern alternatives like \plaintt{std::unique\_ptr} or \plaintt{std::shared\_ptr} to manage heap memory safely (see \hyperref[sec:smart_pointers]{Smart Pointers}).
    \end{itemize}
\end{tipsblock}

\newpage

\section{Condition Statements and Control Structures}

\subsection{If-Else Statements}

The \texttt{if-else} statement is used to execute code based on a condition. If the condition is true, the code inside the \texttt{if} block is executed; otherwise, the code inside the \texttt{else} block is executed.

\begin{codeblock}[language=C++]
if (x > 5) {
    std::cout << "x is greater than 5" << std::endl;
} else if (x > 3) {
    std::cout << "x is greater than 3 but lower than 5" << std::endl;
} else {
    std::cout << "x is not greater than 5" << std::endl;
}
\end{codeblock}

\begin{tipsblock}[Chained Conditions]
    When consecutive \plaintt{if} statements are used instead of \plaintt{else if}, each condition is evaluated on its own. Consequently, even if an earlier condition holds true, the subsequent conditions are still evaluated.
\end{tipsblock}

\subsection{Switch Statements}

The \texttt{switch} statement executes different code blocks based on the value of an expression. When a matching case is found, its code block is executed.

\begin{codeblock}[language=C++]
switch (expression) {
    case constant1:
        // Code to execute if expression == constant1.
        break;
    case constant2:
        // Code to execute if expression == constant2.
        break;
    // ... more cases ...
    default:
        // Code to execute if expression doesn't match any case.
}
\end{codeblock}

\subsection{For loop}

The \texttt{for} loop is used to execute a block of code a specified number of times. It consists of three parts: \textit{initialization}, \textit{condition}, and \textit{post-iteration operation} (tipically increment/decrement).

\begin{codeblock}[language=C++]
for (int i = 0; i < 5; i++) {
    std::cout << i << std::endl;
}
\end{codeblock}

\begin{observationblock}[Counter]
    \plaintt{i} is usually named the \textit{counter} and is used to track the loop's progress. It is incremented or decremented at the end of each iteration. A more general concept, called \textbf{iterator} will provide a generalization for custom objects (see \cref{sec:iterators}).
\end{observationblock}

\subsection{While Loop}

The \texttt{while} loop is used to execute a block of code as long as a specified condition is true.

\begin{codeblock}[language=C++]
int i = 0;
while (i < 5) {
    std::cout << i << std::endl;
    i++;
}
\end{codeblock}

\begin{tipsblock}[Do-While]
    The \plaintt{do\{...\} while(...)} loop is similar to the \plaintt{while} loop, but it always \textbf{executes the block of code at least once} before checking the condition.
\end{tipsblock}

\section{Functions and operators}

\subsection{Functions}

Functions are blocks of code that perform a specific task and can be called from other parts of the program. They are defined with a return type, name, parameters, and a body.

\begin{codeblock}[language=C++, numbers = none]
int add(int a, int b) {
    return a + b;
}

int result = add(3, 4); // Calling the 'add' function
\end{codeblock}

If a function does not output a value, its return type is \texttt{void}. A function can also output a general \texttt{auto} type, which allows the compiler to deduce the return type based on the return statement.

Passing parameters by \textbf{value} creates a copy of the argument, while passing by \textbf{reference} allows the function to modify the original argument.
The function can also return pointers or references, enabling the caller to access or modify the original data.

\begin{codeblock}[language=C++, numbers = none]
// Changes the copy 'x', not the original value.
void modify_by_copy(int x) { x = 20; }

// Modifies the original value via the pointer.
void modify_by_ptr(int* ptr) { *ptr = 30; }

// Modifies the original value through the reference.
void modify_by_ref(int& ref) { ref = 40; }
\end{codeblock}

\subsubsection{Function Overloading} \label{function-overloading}

Function overloading is a feature in C++ that allows you to define multiple functions with the same name but different parameters. The compiler selects the appropriate function based on the number or types of arguments during the function call.

\vspace{-0.5em}

\begin{multicols}{2}
\begin{codeblock}[language=C++]
int add(int a, int b) {
    return a + b;
}
int add(double a, double b) {
    return a + b;
}
\end{codeblock}
\end{multicols}

% \begin{warningblock}[const correctness]
%     \plaintt{const} correctness is essential for writing safe and maintainable code. It prevents unintended modifications by marking parameters as read-only when they should not be altered.
    
%     \begin{itemize}
%         \item \textbf{Avoids unintended changes}: Prevents accidental modifications, improving safety.
%         \item \textbf{Improves readability}: Clearly expresses the intent of function parameters.
%         \item \textbf{Enables optimizations}: Helps the compiler optimize code by ensuring immutability.
%     \end{itemize}

%     \begin{codeblock}[language=C++, numbers = none]
% void print(const std::string& message) {
%     std::cout << message << std::endl;
% }
%     \end{codeblock}
% \end{warningblock}

\subsection{Const Correctness} \label{const-correctness}

\begin{warningblock}[Const Correctness]
    \plaintt{const} correctness is fundamental for writing safe, maintainable, and self-documenting C++ code. Marking variables and function parameters as \plaintt{const}:
    \begin{itemize}
        \item \textbf{Avoids unintended changes}: Prevents accidental modifications, improving safety.
        \item \textbf{Improves readability}: Clearly expresses the intent of function parameters.
        \item \textbf{Enables optimizations}: Helps the compiler optimize code by ensuring immutability.
    \end{itemize}
\end{warningblock}

Consider the following examples that illustrate how \plaintt{const} is used to enforce immutability:

\vspace{-0.5em}
\begin{codeblock}[language=C++, numbers=none]
void print_value(const int x) {
    // x = 42; // Error: Cannot modify 'x'.
}

const int get_copy() {
    const int x = 42;
    return x;
}

int res = get_copy();
res = 10; // Safe, it's a copy!

const int age = 30;              // Immutable variable
const int* ptr_to_const = &age;  // Pointer to a constant integer

ptr_to_const = &res;  // Allowed: the pointer can change where it points
*ptr_to_const = 42;   // Error: cannot modify the value pointed to
\end{codeblock}

In C++, you can declare a \textbf{constant pointer to a non-constant int}, meaning that while the pointer itself cannot be changed to point to a different address, the value stored at that address can be modified. One way to accomplish this is as follows:
    
\begin{codeblock}[language=C++, numbers=none]
int* const ptr_to_int = &res;
\end{codeblock}

Here, ptr\_to\_int is a constant pointer (its address cannot be changed) that points to a non-constant int, allowing modifications to the pointed value.

\begin{tipsblock}[Best Practices]
\begin{itemize}
    \item Use \plaintt{const} for function parameters that should not be altered, for example:
    \vspace{-0.5em}
    \begin{codeblock}[language=C++, numbers=none]
void print(const std::string &message) {
    std::cout << message << std::endl;
}
    \end{codeblock}
    \vspace{-0.5em}
    \item Declare variables as \plaintt{const} if their value is intended to remain constant after initialization.
    \item Ensure that the placement of \plaintt{const} matches your intent (e.g., const ptrs vs ptr to const).
    \item Incorrect or inconsistent use of \plaintt{const} may lead to compiler errors or unexpected behavior.
\end{itemize}
\end{tipsblock}

\vspace{-0.5em}

\subsection{Operators}

Operators are symbols used to perform various operations on variables and values in C++. They provide the means to perform arithmetic, comparisons, and logical evaluations, among other functions. Below is an overview of the most commonly used operator categories:

\vspace{0.5em}

\begin{itemize}
    \item \textbf{Arithmetic operators:} \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\%}
    \item \textbf{Arithmetic and assignment operators:} \texttt{+=}, \texttt{-=}, \texttt{*=}, \texttt{/=}, \texttt{\%=}
    \item \textbf{Comparison operators:} \texttt{==}, \texttt{!=}, \texttt{<}, \texttt{>}, \texttt{<=}, \texttt{>=}, \texttt{<=>} (introduced in C++20)
    \item \textbf{Logical operators:} \texttt{\&\&}, \texttt{||}, \texttt{!}
\end{itemize}

\vspace{0.5em}

\begin{exampleblock}[Operator Usage]
The following code demonstrates the use of various operators:
\vspace{-0.5em}
\begin{codeblock}[language=C++, numbers=none]
int x = 5, y = 3;
bool is_true = (x > y) && (x != 0); // Logical expression.
int z = (x > y) ? 2 : 1;            // Ternary operator.

x += 2; // x becomes 7.
y *= 4; // y becomes 12.
z /= 2; // z becomes 1.
\end{codeblock}
\end{exampleblock}

\subsubsection{Increment and Decrement Operators}

The \textbf{increment} (\texttt{++}) and \textbf{decrement} (\texttt{--}) operators are used to increase or decrease the value of a variable by 1, respectively. They can be applied as either prefix or postfix operators, with different effects on the variable's value.

For increment operators:

\begin{codeblock}[language=C++, numbers=none]
int x = 5;

int a = ++x; // x becomes 6, a is assigned 6.

int b = x++; // b is assigned 6, then x becomes 7.
\end{codeblock}

Similarly, for decrement operators:

\begin{codeblock}[language=C++, numbers=none]
int x = 5;

int c = --x; // x becomes 6, c is assigned 6.

int d = x--; // d is assigned 6, then x becomes 5.
\end{codeblock}

\section{User-defined types}

\begin{itemize}
    \item \textbf{enum}: Defines a set of named constant values.
    \begin{codeblock}[language=C++]
enum Color { RED, GREEN, BLUE };

Color c = RED;
    \end{codeblock}
    \item \textbf{union}: Allows multiple data members to share the same memory location.
    \begin{codeblock}[language=C++]
union Data {
    int x;
    float y;
};

Data d;
d.x = 10;
d.y = 3.14; // Overwrites 'x'
    \end{codeblock}
    \item \textbf{struct}: Groups related data members into a single unit.
    \begin{codeblock}[language=C++]
struct Point {
    int x;
    int y;
};

Point p = {10, 20};
    \end{codeblock}
    \item \textbf{class}: Similar to a struct but with additional features like access control (public, private, protected).
    \begin{codeblock}[language=C++]
class Circle {
public:
    double radius;
    double area() {
        return 3.14 * radius * radius;
    }
};

Circle c;
c.radius = 5.0;
double a = c.area();
    \end{codeblock}
\end{itemize}



\section{Declarations and Definitions}

\begin{itemize}
    \item \textbf{Declaration}: Introduces the name and type of a variable, function, or class without allocating memory or defining its implementation.
\begin{codeblock}[language=C++, numbers=none]
// Declaration
extern int x;
void foo();
\end{codeblock}
    \item \textbf{Definition}: Allocates memory and provides the implementation details for a variable, function, or class.
\begin{codeblock}[language=C++, numbers=none]
// Definition
int x = 10;
void foo() {
    std::cout << "Hello, world!" << std::endl;
}
\end{codeblock}
\end{itemize}


\section{Code Organization}

\textbf{Modular programming} is a software design technique that divides code into separate modules, each responsible for a specific functionality. This approach enhances code readability, maintainability, and reusability.
C++ modules can be organized into header files (\texttt{.h}), for declarations, and source files (\texttt{.cpp}), for definitions.

\begin{exampleblock}[Header and Source Files]
\begin{codeblock}[language=C++]
// module.h (Header file)
#ifndef MODULE_H
#define MODULE_H

void foo();

#endif

// module.cpp (Source file)
#include "module.h"

void foo() {
    std::cout << "Hello, world!" << std::endl;
}
\end{codeblock}
\end{exampleblock}

\subsection{Best practices}

\begin{itemize}
    \item \textbf{Header Guards}: Prevent multiple inclusions of the same header file.
    \item \textbf{Include Guards}: Use \texttt{\#pragma once} or \texttt{\#ifndef} guards to avoid redundant includes.
    \item \textbf{Separation of Concerns}: Keep declarations in header files and definitions in source files.
    \item \textbf{Forward Declarations}: Use forward declarations to reduce dependencies and improve compilation times.
    \item \textbf{Namespace Usage}: Enclose code in namespaces to prevent naming conflicts.
\end{itemize}

\begin{exampleblock}[namespace usage]
\begin{codeblock}[language=C++]
namespace math {
    int add(int a, int b) {
        return a + b;
    }
}

int main() {
    int sum = math::add(10, 20);
    return 0;
}
\end{codeblock}
\end{exampleblock}