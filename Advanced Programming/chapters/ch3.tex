\chapter{Object-Oriented Programming}

\section{Introduction}
\subsubsection{What is OOP}

Object-Oriented Programming (OOP) is a programming paradigm that emphasizes the use of objects to represent real-world entities and concepts.

\begin{definitionblock}[OOP in C++]
    C++ is not (only) an OOP language. It is a \textbf{multi-paradigm programming language} that supports procedural, object-oriented, and generic programming. 
    C++ allows developers to combine these paradigms effectively for various programming tasks.
\end{definitionblock}

\subsubsection{Key Principles of OOP}

OOP is based on several key principles:

\begin{itemize}
    \item \textbf{Encapsulation}: bundles data (attributes) and the functions (methods) that operate on the data into a single unit called an \textit{object}. This promotes data hiding and reduces code complexity.
    \item \textbf{Inheritance}: allows you to create new classes (derived or child classes) based on existing classes (base or parent classes). It enables code reuse and the creation of class hierarchies.
    \item \textbf{Polymorphism}: enables objects from different derived classes to be handled through a common base class. This facilitates code reuse and provides a way to handle objects abstractly.
\end{itemize}

\subsubsection{RAII (Resource Acquisition Is Initialization)}

RAII is a C++ idiom that binds resource management to an object's lifetime. Resources are acquired in the constructor and released in the destructor, ensuring automatic cleanup when the object goes out of scope.

\begin{itemize}
    \item Eliminates manual resource management and reduces leaks.
    \item Ensures deterministic resource release, even in case of exceptions.
    \item Manages memory, file handles, locks, and network connections efficiently.
\end{itemize}

\subsubsection{Advantages of OOP}

OOP offers numerous advantages, including:

\begin{itemize}
    \item \textbf{Modularity}: OOP encourages the division of a complex system into smaller, manageable objects, promoting code modularity and reusability.
    \item \textbf{Maintenance}: Objects are self-contained, making it easier to maintain and update specific parts of the code without affecting other parts.
    \item \textbf{Flexibility}: Inheritance and polymorphism provide flexibility, allowing you to extend and modify the behavior of classes without altering their existing code.
    \item \textbf{Readability}: OOP promotes code readability by organizing data and functions related to a specific object within a class.
\end{itemize}

\newpage

\section{Classes and Objects in C++}

\subsection{Classes and Members}

In C++, a class encapsulates \texttt{data} (member variables) and \texttt{behavior} (member functions), providing a blueprint for creating objects. This encapsulation ensures that data and related functionality are bundled together, promoting modularity and reusability.

The following example defines a simple \texttt{Car} class that models a real-world vehicle. It includes attributes such as the manufacturer, model, and year, along with a method to start the engine.
\begin{codeblock}[language=C++]
class Car {
public:
    std::string manufacturer;
    std::string model;
    unsigned int year;

    void start_engine() {
        std::cout << "Engine started!" << std::endl;
    }
};
\end{codeblock}

\subsubsection{Creating and Using Objects}

Once a class is defined, objects can be instantiated to represent real entities. You can create an instance of the \texttt{Car} class and interact with its members using the dot \texttt{.} operator.

\begin{codeblock}[language=C++, firstnumber=11]
Car my_car;                     // Creating an object of class Car.
my_car.manufacturer = "BMW";
my_car.model = "X5";
my_car.year = 2024;
my_car.start_engine();          // Invoking a method.
\end{codeblock}

C++ allows objects to be managed dynamically using pointers. This provides flexibility, especially when working with objects whose lifetimes extend beyond the current scope. The arrow operator \texttt{->} is used to access members of a pointer to an object.

\begin{codeblock}[language=C++, firstnumber=16]
Car* my_car_ptr = new Car{};
my_car_ptr->manufacturer = "Alfa Romeo";
my_car_ptr->model = "Giulietta";
my_car_ptr->year = 2010;
my_car_ptr->start_engine();     // Invoking a method.
delete my_car_ptr;              // Releasing allocated memory.
\end{codeblock}

\subsubsection{Member Variables and Functions}

A class consists of two main components:

\begin{itemize}
    \item \textbf{Member Variables}: Store the state of an object. They are also known as attributes or fields.
    \item \textbf{Member Functions}: Define the behavior of an object. They are also known as methods.
\end{itemize}

\vspace{1em}

In the previous example, the member variables (\texttt{manufacturer}, \texttt{model}, \texttt{engine\_running}) store the car's state, while member functions (\texttt{start\_engine}, \texttt{is\_running}) define its behavior.

\subsubsection{Static Members}

Static members are shared by all instances of a class. They are declared with the \texttt{static} keyword and accessed using the class name rather than an object. Consider the \texttt{Circle} class below, which uses a static constant for \texttt{PI}:

\begin{codeblock}[language=C++]
class Circle {
public:
    static const double PI = 3.14159265359;   // Static member.
    double radius;                            // Non-static member.

    double calculate_area() {
        return PI * radius * radius;
    }
    
    static void print_shape_name() {
        std::cout << "This is a circle." << std::endl;
    }
};
\end{codeblock}
Static members can be accessed using the class name directly, while non-static members require an instance of the object:

\begin{codeblock}[language=C++, firstnumber=14]
Circle circle;
circle.radius = 5.0;
const double area = circle.calculate_area();  // non-static member.
const double pi_value = Circle::PI;           // static member.
Circle::print_shape_name();
\end{codeblock}

\subsubsection{Const Members}

The keyword \texttt{const} can be applied to member variables and member functions to indicate immutability. In the example below, the constructor initializes a constant member, and the member function \texttt{print\_value} is declared as \texttt{const} to signal that it does not modify the object.

\begin{codeblock}[language=C++]
class MyClass {
public:
    MyClass(int x) : value(x) {}
        
    void print_value() const {
        // value *= 2; // Illegal: cannot modify a const member.
        std::cout << "Const version: " << value << std::endl;
    }
    
    const int value;
};
\end{codeblock}

\begin{tipsblock}[\plaintt{mutable} Keyword]
    If a const member function needs to modify a member variable, that variable can be declared as \plaintt{mutable} (although this should be used sparingly).

\begin{codeblock}[language=C++, numbers=none]
mutable int var = 0; // Can be modified in a const member function
\end{codeblock}
\end{tipsblock}
\begin{exampleblock}[Const and Non-Const Member Functions]
    Here is an example illustrating both const and non-const versions of a member function:
    \begin{codeblock}[language=C++]
class Counter {
public:
    Counter() : count(0) {}

    // Non-const version can modify the object
    void increment() {
        count++;
    }

    // Const version can only read the object
    int get_count() const {
        return count;
    }

private:
    int count;
};

Counter c1;       // Non-const object
const Counter c2; // Const object

c1.get_count();   // OK      non-const obj can call const func
c1.increment();   // OK      non-const obj can call non-const func

c2.get_count();   // OK      const obj can call const func
c2.increment();   // Error   const obj cannot call non-const func
    \end{codeblock}
\end{exampleblock}

\subsubsection{The \texttt{this} Pointer}

The \texttt{this} pointer is automatically passed to non-static member functions and points to the object invoking the function. It is useful for resolving ambiguity between member variables and parameters.

\begin{codeblock}[language=C++]
class MyClass {
public:
    int x;

    void print_x() const {
        std::cout << "Value of x: " << this->x << std::endl;
    }
};
\end{codeblock}


\subsection{Constructors and Destructors}

Constructors are special member functions that initialize objects when they are created. They share the same name as the class and may accept arguments to initialize member variables.

\subsubsection{Default Constructor}

A default constructor takes no arguments. If a class has no explicitly defined constructor, C++ generates a default constructor automatically.

\begin{codeblock}[language=C++]
class MyClass {
public:
    // Default constructor.
    MyClass() = default;

    std::string name;
    unsigned int length;
};

MyClass obj;    // Default initialization.
MyClass obj2{}; // Uniform initialization (preferred).
MyClass* ptr = new MyClass(); // Calls the default constructor.
\end{codeblock}

\begin{observationblock}[Default Constructor and Initialization]
If you provide any custom constructors, C++ \textit{will not generate a default constructor} unless explicitly defined.

Default initialization of primitive types (e.g., \plaintt{int}, \plaintt{double}) sets them to zero, while objects may be initialized by their own default constructors.
\end{observationblock}

\vspace{-0.5em}

\subsubsection{Parameterized Constructor}

\vspace{-0.3em}

A parameterized constructor allows objects to be initialized with specific values.

\vspace{-0.3em}

\begin{codeblock}[language=C++]
class Student {
public:
    Student(std::string name, unsigned int age) {
        this->name = name;
        this->age = age;
    }

    std::string name;
    unsigned int age;
};

Student student1("Alice", 20); // initialization using a constructor.
Student student2{"Bob", 23}; // Uniform initialization.
\end{codeblock}

\vspace{-0.3em}

A good practice is to use an \textbf{initializer list} to initialize member variables in the constructor:

\vspace{-0.3em}

\begin{codeblock}[language=C++]
class Rect {
public:
    Rect(double length, double width) : length(length), width(width) {
        // Constructor body (if needed).
    }

    double calculate_area() const {
        return length * width;
    }

    double length;
    double width;
};

Rect rect{5.0, 3.0}; // initialization using an initializer list.
const double area = rect.calculate_area();
\end{codeblock}

When using an initializer list, the member variables \textbf{must be initialized in the order they are declared} in the class definition.

\vspace{-0.3em}

\begin{tipsblock}[Initializer List]
Using an initializer list avoids redundant assignments and improves efficiency.
\end{tipsblock}

\vspace{-1em}

\subsubsection{Copy Constructor and Copy Assignment}

\vspace{-0.3em}

A copy constructor creates a new object as a copy of an existing one, while the copy assignment operator assigns the contents of one object to another existing object.

\vspace{-0.3em}

\begin{codeblock}[language=C++, numbers=none]
class Book {
public:
    Book(std::string title, std::string author) 
        : title(title), author(author) {}

    // Copy constructor.
    Book(const Book& other)
        : title(other.title), author(other.author) {}

    // Copy assignment operator.
    Book& operator=(const Book& other) {
        if (this != &other) {
            title = other.title;
            author = other.author;
        }
        return *this;
    }

    void display_info() const {
        std::cout << "Title:" << title << ", Author:" << author << "\n";
    }

    std::string title;
    std::string author;
};

Book book1{"The Catcher in the Rye", "J.D. Salinger"};
Book book2 = book1; // Copy constructor.
Book book3{"Marcovaldo", "I. Calvino"};
book3 = book1; // Copy assignment operator.
\end{codeblock}

\begin{observationblock}[Pass and Return by Value]
    When passing or returning objects by value, the copy constructor is invoked to create a copy of the object.

\begin{codeblock}[language=C++]
void some_function(Student s) {
    // Calls the copy constructor when s is passed.
}

Student create_student() {
    Student s{"Bob", 22};
    return s; // Calls the copy constructor when s is returned.
}
\end{codeblock}
\end{observationblock}

\subsubsection{Destructor}

\vspace{-0.2em}

A destructor is a special member function that cleans up resources when an object is destroyed. It has the same name as the class but is prefixed with \texttt{\textasciitilde}. Destructors are automatically called when:
\begin{itemize}
    \item An object goes out of scope
    \item The \texttt{delete} operator is used on a pointer to the object
    \item The program ends and static/global objects are destroyed
\end{itemize}

\vspace{-0.5em}

\begin{codeblock}[language=C++]
class FileHandler {
public:
    FileHandler(std::string filename) : filename(filename) {
        file.open(filename);
    }

    ~FileHandler() {
        if (file.is_open()) {
            file.close();
        }
    }

    std::string filename;
    std::ofstream file;
};

{ // The object is automatically destroyed when it goes out of scope.
    FileHandler file{"data.txt"};
} // Destructor is called here, ensuring proper resource cleanup.
\end{codeblock}

\vspace{-0.7em}

\begin{observationblock}[Rule of Three]
    Copy constructor, copy assignment operator and destructor are part of the \textbf{Rule of Three} in C++, which states that if a class defines any of the following:
    \begin{itemize}
        \item Destructor
        \item Copy constructor
        \item Copy assignment operator
    \end{itemize}
    then it should provide all three to ensure proper memory management.
\end{observationblock}

\vspace{-0.8em}

\subsubsection{Compiler-Generated Special Member Functions}

\vspace{-1em}

\renewcommand{\arraystretch}{1.35}
\setlength{\tabcolsep}{2.8pt}

\begin{table}[H]
    \centering
    \captionsetup{justification=centering, margin=0.1cm, labelfont=bf, font=small}
    \caption{The compiler automatically generates special member functions when not explicitly defined. \cite{howardhinnant}}
    \label{tab:special_members}
    \vspace{-0.4em}
    \small
    \begin{tabular}{|>{\centering\columncolor{gray!20}\arraybackslash}m{2.9cm}|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{2cm}|}
    \hline
    \rowcolor{gray!30} \textbf{user declares} & \textbf{default constructor} & \textbf{destructor} & \textbf{copy constructor} & \textbf{copy assignment} & \textbf{move constructor} & \textbf{move assignment} \\
    \hline
    Nothing & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted \\
        \hline
        Any constructor & \cellcolor{yellow!20}not declared & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted \\
        \hline
        default constructor & \cellcolor{green!20}user declared & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted \\
        \hline
        destructor & \cellcolor{blue!15}defaulted & \cellcolor{green!20}user declared & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted & \cellcolor{yellow!20}not declared & \cellcolor{yellow!20}not declared \\
        \hline
        copy constructor & \cellcolor{yellow!20}not declared & \cellcolor{blue!15}defaulted & \cellcolor{green!20}user declared & \cellcolor{blue!15}defaulted & \cellcolor{yellow!20}not declared & \cellcolor{yellow!20}not declared \\
        \hline
        copy assignment & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted & \cellcolor{green!20}user declared & \cellcolor{yellow!20}not declared & \cellcolor{yellow!20}not declared \\
        \hline
        move constructor & \cellcolor{yellow!20}not declared & \cellcolor{blue!15}defaulted & \cellcolor{red!20}deleted & \cellcolor{red!20}deleted & \cellcolor{green!20}user declared & \cellcolor{yellow!20}not declared \\
        \hline
        move assignment & \cellcolor{blue!15}defaulted & \cellcolor{blue!15}defaulted & \cellcolor{red!20}deleted & \cellcolor{red!20}deleted & \cellcolor{yellow!20}not declared & \cellcolor{green!20}user declared \\
        \hline
        \end{tabular}
        \vspace{-0.5em}
    \end{table}

\newpage
\subsection{The \plaintt{inline} Directive}

The \texttt{inline} keyword in C++ suggests that the compiler replaces a function call with the actual function code at the call site. This can reduce function call overhead and improve performance for small, frequently used functions.

\textbf{Syntax}
\begin{codeblock}[language=C++, numbers=none]
// Inline function definition.
inline int add(int a, int b) {
    return a + b;
}

// Function call.
const int result = add(5, 7);
std::cout << "Result: " << result << std::endl;
\end{codeblock}

Inline functions have the following characteristics:

\begin{itemize}
    \item \textbf{Limited to small functions}: Inlining is beneficial for short functions but can lead to code bloat for larger functions.
    \item \textbf{Compiler optimization}: The \texttt{inline} keyword is only a suggestion; the compiler may choose whether to inline a function based on optimization settings.
    \item \textbf{Usage in header files}: Inline functions should be defined in header files to avoid multiple definition errors, but proper use of header guards is essential.
    \item \textbf{Impact on readability}: Excessive inlining can make debugging harder and lead to poor code organization.
\end{itemize}

    \textbf{Advantages}
    \begin{itemize}
        \item Reduces function call overhead.
        \item Eliminates stack frame creation for simple functions.
        \item Helps avoid multiple definitions across translation units.
        \item Useful for small, performance-critical functions.
    \end{itemize}
    
    \textbf{Considerations}
    \begin{itemize}
        \item Excessive use can increase executable size.
        \item Compiler may ignore the \texttt{inline} directive if deemed inefficient.
        \item Debugging inlined functions is more difficult.
        \item Should be used cautiously to maintain code clarity.
    \end{itemize}

\begin{tipsblock}[When to Use \plaintt{inline}]

    The \plaintt{inline} directive is most effective when:

    \begin{itemize}
        \item Use for very small functions, such as one-liners.
        \item Use when function call overhead is significant.
        \item Avoid inlining large or recursive functions.
        \item Ensure proper placement in header files to prevent linkage issues.
    \end{itemize}
\end{tipsblock}

\newpage

\subsection{In-Class and Out-of-Class Definitions}

In C++, member functions of a class can be defined either inside the class declaration (in-class, implicitly \texttt{inline}) or separately in a source file (out-of-class). Each approach has its advantages and trade-offs.

\vspace{-0.5em}

\subsubsection{In-Class Definition (Implicitly Inline)}

\vspace{-0.5em}

A member function defined inside the class is automatically considered \texttt{inline}. This is common for short functions that are one-liners or concise operations.

\begin{codeblock}[language=C++, numbers=none]
// my_class.hpp
class MyClass {
public:
    // Inline function defined inside the class.
    int add(int a, int b) {
        return a + b;
    }
};
\end{codeblock}

The compiler treats this as if it were explicitly marked \texttt{inline} when defined outside the class.

\begin{codeblock}[language=C++, numbers=none]
// my_class.hpp
class MyClass {
public:
    int add(int a, int b);
};

// Inline keyword is implicit when defined inside the class.
inline int MyClass::add(int a, int b) {
    return a + b;
}
\end{codeblock}

\begin{minipage}[H]{0.48\textwidth}
    \textbf{Advantages}
    \begin{itemize}
        \item Improves readability for simple functions.
        \item Allows potential inlining by the compiler, reducing function call overhead.
    \end{itemize}
\end{minipage}%
\hfill
\begin{minipage}[H]{0.49\textwidth}
    \textbf{Disadvantages}
    \begin{itemize}
        \item May lead to code bloat with large functions.
        \item Changes to the function force recompilation of all translation units, including header files.
    \end{itemize}
\end{minipage}

\subsubsection{Out-of-Class Definition (Separation of Interface and Implementation)}

Member functions can also be declared in the class but defined separately in a source file (\texttt{.cpp}). This is typically done for larger functions or when separating interface from implementation.

\begin{codeblock}[language=C++, numbers=none]
// my_class.hpp
class MyClass {
public:
    int add(int a, int b); // Function declaration.
};
\end{codeblock}

\begin{codeblock}[language=C++, numbers=none]
// my_class.cpp
#include "my_class.hpp"

int MyClass::add(int a, int b) {
    return a + b;
}
\end{codeblock}

\begin{minipage}{0.48\textwidth}
    \textbf{Advantages}
    \begin{itemize}
        \item Improves code organization.
        \item Changes to function implementation do not require recompilation of all translation units.
    \end{itemize}
\end{minipage}%
\hfill
\begin{minipage}{0.48\textwidth}
    \textbf{Disadvantages}
    \begin{itemize}
        \item Slightly more verbose.
        \item Requires managing separate \texttt{.cpp} files.
    \end{itemize}
\end{minipage}

\begin{tipsblock}[Best Practices for Function Definitions]
    \begin{enumerate}
        \item Use \textbf{in-class definitions} for very short functions (e.g., accessors, mutators) where inlining might improve performance.
        \item Use \textbf{out-of-class definitions} for more complex functions to keep headers clean and separate interface from implementation.
        \item Balance readability, maintainability, and performance when deciding where to define functions.
    \end{enumerate}
\end{tipsblock}

In practice, a combination of both approaches is used to maintain structured and efficient code.


\subsection{Encapsulation and Access Control}

Encapsulation is a key principle in object-oriented programming (OOP) that bundles data (attributes) and methods (functions) into a single unit: an object.

It restricts direct access to an object's internal state, ensuring data integrity and security.

\subsubsection{Encapsulation in C++}

Encapsulation allows defining a clear interface while hiding implementation details. Data members should generally be private, with public methods providing controlled access.

\begin{exampleblock}[Encapsulation Example]
\begin{codeblock}[language=C++, numbers=none]
class BankAccount {
public:
    BankAccount(std::string account_holder, double balance)
        : account_holder(account_holder), balance(balance) {}

    void deposit(double amount) {
        balance += amount;
    }

    double get_balance() const {
        return balance;
    }

private:
    std::string account_holder;
    double balance;
};
\end{codeblock}
\end{exampleblock}

\subsubsection{Access Specifiers in C++}

C++ provides three access specifiers to control member visibility:

\begin{itemize}
    \item \texttt{public}: Accessible from any part of the program (forms the class's public interface).
    \item \texttt{private}: Only accessible within the class itself (internal implementation).
    \item \texttt{protected}: Similar to \texttt{private}, but also accessible in derived classes (used in inheritance).
\end{itemize}

\begin{codeblock}[language=C++, numbers=none]
class MyClass {
public:
    int public_var;      // Accessible from anywhere.
    void public_func() { /* ... */ }

private:
    int private_var;     // Accessible only within this class.
    void private_func() { /* ... */ }
};
\end{codeblock}

\subsubsection{Class vs. Struct}

In C++, both \texttt{class} and \texttt{struct} can be used to define objects with member variables and functions.

\vspace{0.5em}

The primary difference between them lies in their \textbf{default access specifiers}:

\begin{itemize}
    \item In a \texttt{class}, members are \textbf{private} by default.
    \item In a \texttt{struct}, members are \textbf{public} by default.
\end{itemize}

\begin{codeblock}[language=C++, numbers=none]
// Class vs. Struct Example
class MyClass {
    int x; // Private by default.
public:
    int y; // Explicitly public.
};

struct MyStruct {
    int x; // Public by default.
private:
    int y; // Explicitly private.
};
\end{codeblock}

\subsubsection{When to Use Class vs. Struct}

While functionally equivalent, structs and classes serve different purposes in common C++ conventions.

\vspace{0.5em}

Use \texttt{class} when:
\vspace{0.5em}
\begin{itemize}
    \item Encapsulating data with private members
    \item Defining objects with complex behavior
    \item Implementing OOP concepts (e.g. inheritance)
    \item Maintaining strong encapsulation
\end{itemize}

\vspace{0.5em}

Use \texttt{struct} when:
\vspace{0.5em}
\begin{itemize}
    \item Grouping related public variables
    \item Using simple data structures (e.g. point, color)
    \item Interacting with C-style structs or APIs
    \item Defining POD (Plain Old Data) types
\end{itemize}

\subsubsection{Getter and Setter Methods}

Getter and setter methods (also known as \textbf{accessors and mutators}) provide controlled access to private member variables.

\begin{itemize}
    \item \textbf{Getters}: Allow reading private data.
    \item \textbf{Setters}: Allow modifying private data with validation or restrictions.
\end{itemize}

\begin{exampleblock}[Getter and Setter]
\begin{codeblock}[language=C++]
class TemperatureSensor {
public:
    double get_temperature() const {
        return temperature;
    }

    void set_temperature(double new_temperature) {
        if (new_temperature >= -50.0 && new_temperature <= 150.0) {
            temperature = new_temperature;
        } else {
            std::cout << "Invalid temperature value!" << std::endl;
        }
    }

private:
    double temperature;
};
\end{codeblock}
\end{exampleblock}

Using getters and setters enforces encapsulation while allowing controlled data access.

\subsection{Friend Classes}

A \texttt{friend} class allows another class to access its private and protected members. This is useful when two classes need close interaction but maintaining strict encapsulation is impractical.

\vspace{0.5em}

Let's consider a \texttt{Circle} class with a private member \texttt{radius}.

\begin{codeblock}[language=C++, numbers=none]
// circle.hpp
class Circle {
public:
    friend class Cylinder;
    // Cylinder class has access to private members of Circle.

    Circle(double r) : radius(r) {}

    double get_area() const {
        return 3.14159265359 * radius * radius;
    }

private:
    double radius;
};
\end{codeblock}

Let's consider now a \texttt{Cylinder} class that requires access to the private member \texttt{radius} of the \texttt{Circle} class:

\begin{codeblock}[language=C++, numbers=none]
// cylinder.hpp
class Cylinder {
public:
    Cylinder(const Circle &circle, double height)
        : circle(circle), height(height) {}
    
    double get_volume() const {
        // Accessing the private member 'radius' of Circle.
        return circle.radius * circle.radius * height;
    }

private:
    double height;
    const Circle circle;
};

Circle circle{1.0};
Cylinder cylinder{circle, 0.5};
const double volume = cylinder.get_volume();
\end{codeblock}

\begin{tipsblock}[Best Practices for Friend Classes]
    \begin{itemize}
        \item \textbf{Minimize usage}: Prefer encapsulation unless two classes require deep interaction.
        \item \textbf{Use only when necessary}: Friend classes break encapsulation, so they should be well justified.
        \item \textbf{Maintain modularity}: Avoid excessive interdependencies between classes.
    \end{itemize}
\end{tipsblock}

Friend classes allow controlled access to private members but should be used sparingly to maintain encapsulation principles.


\subsection{Operator Overloading}

Operator overloading in C++ allows defining custom behaviors for operators when used with user-defined classes. This makes objects behave more naturally and improves code readability.

\begin{table}[H]
    \centering
    \setlength{\tabcolsep}{20pt}
    \begin{tabulary}{\linewidth}{@{} L C @{}}
        \toprule
        \hfill \textbf{Category} \hfill & \textbf{Operators} \\
        \midrule
        Arithmetic & \plaintt{+}, \plaintt{-}, \plaintt{*}, \plaintt{/}, \plaintt{\%} \\
        Comparison & \plaintt{==}, \plaintt{!=}, \plaintt{<}, \plaintt{>}, \plaintt{<=}, \plaintt{>=}, \plaintt{<=>} (C++20) \\
        Assignment & \plaintt{=}, \plaintt{+=}, \plaintt{-=}, \plaintt{*=} \\
        Increment/Decrement & \plaintt{++}, \plaintt{--} \\
        Stream & \plaintt{<<} (output), \plaintt{>>} (input) \\
        Subscript & \plaintt{[]} (array-like behavior) \\
        Function Call & \plaintt{()} (used in functor classes) \\
        Pointer & \plaintt{->}, \plaintt{*} (smart pointers, iterators) \\
        \bottomrule
    \end{tabulary}
    \caption{Commonly Overloaded Operators in C++}
\end{table}

\newpage

By overloading operators you can extend their functionality for custom types. Instead of writing verbose function calls, operator overloading lets you use familiar syntax for objects.

\begin{exampleblock}[Operator Overloading]
\begin{codeblock}[language=C++, numbers=none]
class Complex {
public:
    Complex(double r, double i) : real(r), imag(i) {}

    // Overloading the + operator.
    Complex operator+(const Complex& other) {
        return Complex(real + other.real, imag + other.imag);
    }

    void print() const {
        std::cout << real << " + " << imag << "i" << std::endl;
    }

private:
    double real, imag;
};

Complex a{2.0, 3.0};
Complex b{1.0, 2.0};
Complex c = a + b; // Using the overloaded '+' operator.
c.print();
\end{codeblock}
\end{exampleblock}

Operators can be overloaded as \textbf{member functions} or \textbf{non-member functions}.

\subsubsection{Overloading as a Member Function}

If the left operand is an object of the class, the operator can be overloaded as a member function.

\begin{codeblock}[language=C++, numbers=none]
// Overloading as a Member Function
class Vector {
public:
    Vector(int x, int y) : x(x), y(y) {}

    Vector operator+(const Vector& other) {
        return Vector(x + other.x, y + other.y);
    }

    void print() const {
        std::cout << "(" << x << ", " << y << ")" << std::endl;
    }

private:
    int x, y;
};

Vector v1{2, 3}, v2{1, 1};
Vector result = v1 + v2; // Works because + is a member function.
result.print();
\end{codeblock}

\subsubsection{Overloading as a Non-Member Function}

If the left operand is not an object of the class, the operator must be overloaded as a non-member function.

\begin{codeblock}[language=C++, numbers=none]
// Overloading as a Non-Member Function (Friend Function)
class MyClass {
public:
    MyClass(int v) : value(v) {}

    // Declaring the '<<' operator as a friend function.
    friend std::ostream& operator<<(std::ostream& os, const MyClass& obj);

private:
    int value;
};

// Overloading the '<<' operator as a non-member function.
std::ostream& operator<<(std::ostream& os, const MyClass& obj) {
    os << obj.value;
    return os;
}

MyClass obj{42};
std::cout << obj << std::endl; // Calls the overloaded operator.
\end{codeblock}

\begin{tipsblock}[Operator Overloading Guidelines]
    \begin{enumerate}

        \item \textbf{Operators that cannot be overloaded}
        
        Some operators like \plaintt{::}, \plaintt{.*}, and \plaintt{? :} cannot be overloaded.
        
        \item \textbf{Preserve the operator's meaning}
        
        Overloading should make sense in the class's context (e.g., \plaintt{+} for addition).
        
        \item \textbf{Respect operator precedence}
        
        Overloaded operators should follow the same precedence as their built-in counterparts.
        
        \item \textbf{Avoid excessive overloading}
        
        Overloading too many operators can make code hard to maintain.

    \end{enumerate}
\end{tipsblock}

Operator overloading enhances code readability when used correctly, making custom types feel like native types.

\newpage



\section{Class Collaborations}

In object-oriented programming, classes do not exist in isolation; they often collaborate in various ways to form complex software systems.

\vspace{0.8em}

These collaborations can be classified into different types of relationships.

\subsection{Association}

A \textbf{"\textit{loose}" relationship} where one class holds a reference or pointer to another but does not control its lifetime. This is useful for relationships where objects interact without being strongly coupled.

\vspace{0.5em}

Here's an example of Association: A Student can be associated with multiple Courses.

Let's firstly define the \texttt{Course} class:

\begin{codeblock}[language=C++]
// course.hpp
class Course {
public:
    Course(const std::string& name) : course_name(name) {}

    const std::string& get_course_name() const {
        return course_name;
    }

private:
    std::string course_name;
};
\end{codeblock}

Next, let's define the \texttt{Student} class which can maintain associations with multiple courses through enrollment:

\begin{codeblock}[language=C++]
// student.hpp
class Student {
public:
    Student(const std::string& name) : student_name(name) {}

    void enroll_course(Course *course) {
        enrolled_courses.push_back(course);
    }

    void list_enrolled_courses() const {
        std::cout << student_name << " is enrolled in:" << std::endl;
        for (const auto& course : enrolled_courses) {
            std::cout << "- " << course->get_course_name() << std::endl;
        }
    }

private:
    std::string student_name;
    std::vector<Course*> enrolled_courses; // Association with Course.
};
\end{codeblock}

The \texttt{Student} class has a vector of \texttt{Course} pointers, representing an association between the two classes.

This implements a many-to-many relationship pattern, where a student can be enrolled in multiple courses, and courses can have multiple students.

\vspace{-0.5em}

\begin{codeblock}[language=C++]
// main.cpp
Course math{"Math"};
Course physics{"Physics"};
Course biology{"Biology"};

Student alice{"Alice"};
Student bob{"Bob"};

alice.enroll_course(&math);
alice.enroll_course(&physics);
bob.enroll_course(&biology);
bob.enroll_course(&physics);

alice.list_enrolled_courses(); // Alice is enrolled in: - Math - Physics
bob.list_enrolled_courses(); // Bob is enrolled in: - Biology - Physics
\end{codeblock}

\vspace{-0.5em}

Associations are useful for modeling relationships between classes without strong dependencies: one class can exist without the other.

\vspace{-0.5em}

\subsection{Aggregation}

A \textbf{"\textit{has-a}" relationship} where one class contains another, but the contained object can exist independently.

\begin{codeblock}[language=C++, numbers=none]
class Wheel {
public:
    void rotate() { /* ... */ }
};

class Car {
private:
    std::vector<Wheel*> wheels; // Car uses existing Wheels.

public:
    Car(std::vector<Wheel*>& wheels) : wheels(wheels) {}

    void drive() {
        for (auto* wheel : wheels) {
            wheel->rotate();
        }
    }
};
\end{codeblock}

In this example \texttt{Wheel} objects wheels can exist independently of the \texttt{Car}:

\begin{codeblock}[language=C++]
    Wheel front_left, front_right, rear_left, rear_right;
    std::vector<Wheel*> wheel_set = {&front_left, &front_right, &rear_left, &rear_right};
    
    Car my_car(wheel_set); // Car uses externally created Wheels.
    my_car.drive(); // Wheels are rotated.
\end{codeblock}

Aggregation is useful for modeling objects that are composed of other objects but can exist independently.

\subsection{Pointer vs. Reference for Aggregation}

Choosing between pointers and references when aggregating polymorphic objects depends on the intended behavior.

\vspace{0.75em}

\begin{minipage}[H]{0.48\textwidth}
    \textbf{Reference-Based Aggregation}
    \begin{itemize}
        \item Use a \textbf{(const) reference} if the object remains unchanged over time.
        \item Guarantees that an object always exists.
        \item Not default-constructible.
    \end{itemize}
\end{minipage}%
\hfill
\begin{minipage}[H]{0.48\textwidth}
    \textbf{Pointer-Based Aggregation}
    \begin{itemize}
        \item Use a \textbf{pointer} if the object may change over time.
        \item Initialize raw pointers to \texttt{nullptr}.
    \end{itemize}
\end{minipage}

\begin{observationblock}[Memory Management]
    Raw pointers can cause memory issues; consider smart pointers as \plaintt{std::unique\_ptr} or \plaintt{std::shared\_ptr} for automatic resource management.
\end{observationblock}

\subsection{Composition}

Composition is a stronger \textbf{"\textit{part-of}" relationship} where the contained object is an integral part of the containing object and cannot exist independently. The lifetime of the contained object is tied directly to the containing object's lifetime.

\vspace{-0.5em}

\begin{codeblock}[language=C++, numbers=none]
class Room {
public:
    void clean() { /* ... */ }
};

class Apartment {
private:
    Room living;  // Rooms cannot exist without an Apartment.
    Room kitchen;
    Room bedroom;

public:
    void clean() { 
        living.clean(); 
        kitchen.clean(); 
        bedroom.clean(); 
    }
};
\end{codeblock}

\vspace{-0.5em}

When the containing object is destroyed, all composed objects are automatically destroyed as well.

\begin{codeblock}
Apartment my_apartment;
my_apartment.clean(); // Cleans all rooms.    
\end{codeblock}

\begin{observationblock}[Composition vs. Aggregation]
    Composition and aggregation are both forms of object containment, but they differ in the strength of the relationship:
    \begin{itemize}
        \item \textbf{Composition}: Stronger relationship where the contained object is part of the containing object.
        \item \textbf{Aggregation}: Weaker relationship where the contained object can exist independently.
    \end{itemize}
\end{observationblock}

\subsection{Views (Proxies)}

A proxy (or view) is a specialized form of aggregation that provides an alternative interface for accessing an object's elements. A proxy does not store the actual data but redirects access to another underlying object while applying specific transformations or constraints.

\begin{codeblock}[language=C++]
class Matrix {
public:
    double & operator()(int i, int j);
};

class DiagonalView {
public:
    DiagonalView(Matrix &mat) : mat(mat) {}

    double & operator()(int i, int j) {
        return (i == j) ? mat(i, i) : 0.0; 
    }

private:
    Matrix &mat;
};
\end{codeblock}

\texttt{DiagonalView} provides a restricted view of a Matrix, allowing access only to diagonal elements. It prevents modifications to off-diagonal elements by returning \texttt{0.0} for those cases.

\newpage

\section{Inheritance and Polymorphism}

\subsection{Inheritance}

Inheritance is a fundamental concept in object-oriented programming that allows a new class (the derived or subclass) to inherit properties and behaviors from an existing class (the base or superclass). It establishes an \textbf{"\textit{is-a}" relationship}, enabling code reuse and extension.

For example, a\texttt{Shape} class can serve as a base for\texttt{Circle},\texttt{Rectangle}, and\texttt{Triangle} classes, all of which share common characteristics while extending functionality.

\subsubsection{Inheritance in C++}

In C++, inheritance is specified using using the \texttt{class} or \texttt{struct} keyword followed by a colon \texttt{:} and an access specifier (\texttt{public},\texttt{protected}, or\texttt{private}) and the name of the base class.

\begin{exampleblock}[Inheritance]

    An example of inheritance is shown below, where the\texttt{Circle} class inherits from the\texttt{Shape} class:

\begin{codeblock}[language=C++]
class Shape { // Base class.
public:
    void f() { std::cout << "f (base class)." << std::endl; }
    void draw() { std::cout << "Drawing a shape." << std::endl; }
};

class Circle : public Shape { // Derived class.
public:
    void g() { std::cout << "g (derived class)." << std::endl; }
    void draw() { std::cout << "Drawing a circle." << std::endl; }
};

Circle circle;
circle.f();    // Calls f() from Shape
circle.g();    // Calls g() from Circle
circle.draw(); // Calls draw() from Circle (overrides Shape method)
\end{codeblock}
\end{exampleblock}

\subsubsection{Inheritance and Access Control}

The choice of access specifier determines how base class members are inherited:

\begin{itemize}
    \item \textbf{Public Inheritance}: Preserves the original access specifiers. Public members remain public, protected members remain protected.
    \item \textbf{Protected Inheritance}: Public members become protected; protected members remain protected.
    \item \textbf{Private Inheritance}: Public and protected members become private.
\end{itemize}

\begin{codeblock}[language=C++]
class Base {
public:
    int public_data;
protected:
    int protected_data;
private:
    int private_data;
};
\end{codeblock}

The accessibility of each member in the derived class varies based on the inheritance type. The \cref{tab:inheritance_access} below illustrates how different inheritance types affect member accessibility:

\renewcommand{\arraystretch}{1}  % Reduce row height (default is 1.0)
\begin{table}[H]
    \centering
    \small
    \begin{tabular}{|p{3.5cm}|p{3.5cm}|p{3.5cm}|}
        \hline
        \textbf{Member} & \textbf{Original Access} & \textbf{Inherited Access} \\
        \hline
        \multicolumn{3}{|c|}{\textbf{Public Inheritance}} \\
        \hline
        public\_data & public & public \\
        protected\_data & protected & protected \\
        private\_data & private & inaccessible \\
        \hline
        \multicolumn{3}{|c|}{\textbf{Protected Inheritance}} \\
        \hline
        public\_data & public & protected \\
        protected\_data & protected & protected \\
        private\_data & private & inaccessible \\
        \hline
        \multicolumn{3}{|c|}{\textbf{Private Inheritance}} \\
        \hline
        public\_data & public & private \\
        protected\_data & protected & private \\
        private\_data & private & inaccessible \\
        \hline
    \end{tabular}
    \caption{Access Control in Different Types of Inheritance}
    \label{tab:inheritance_access}
\end{table}

\begin{codeblock}[language=C++]
class DerivedPublic : public Base { 
    // public_data remains public.
    // protected_data remains protected.
    // private_data is inaccessible.
};

class DerivedProtected : protected Base { 
    // public_data becomes protected.
    // protected_data remains protected.
    // private_data is inaccessible.
};

class DerivedPrivate : private Base { 
    // public_data becomes private.
    // protected_data becomes private.
    // private_data is inaccessible.
};
\end{codeblock}

\subsubsection{Construction of a Derived Class}

When constructing a derived object:

\begin{enumerate}
    \item The base class constructor is called first.
    \item The derived class constructor executes, initializing its own members.
\end{enumerate}

\begin{codeblock}[language=C++, numbers=none]
class BaseClass {
public:
    BaseClass(int base_param) { /* Initialize base members */ }
};

class DerivedClass : public BaseClass {
public:
    DerivedClass(int derived_param, int base_param) 
        : BaseClass(base_param) { /* Initialize derived members */ }
};
\end{codeblock}

\subsubsection{Delegating Constructor}

In the constructor of a derived class, you can call the constructor of the base class, which is useful if you need to pass arguments. If no arguments are passed, the default constructor of the base class is used (in this case, the base class must be default constructible).

\begin{codeblock}[language=C++]
class B {
public:
    B(double x) : x(x) { /* ... */ }
private:
    double x;
};

class D : public B {
public:
    D(int i, double x) : B(x), my_i(i) { }
private:
    int my_i;
};

D d(4, 12.0); // Initializes d.x = 12.0, d.my_i = 4
\end{codeblock}

\subsubsection{Inheriting Constructors}

Constructors are not inherited by default, but they can be explicitly made available in a derived class using\texttt{using}.

\begin{codeblock}[language=C++]
class B {
public:
    B(double x) : x(x) { /* ... */ }
};

class D : public B {
    using B::B; // Inherits B constructor.
private:
    int my_i = 10;
};

D d(12.0);
\end{codeblock}

In the example above, when you create an instance like D d(12.0), the using declaration makes \texttt{B}'s constructor available in \texttt{D}. The constructor \texttt{B::B(double)} is called with \texttt{12.0}, setting \texttt{d.x} accordingly, while \texttt{d.my\_i} is automatically initialized to its default value of \texttt{10}.

\subsubsection{Destruction of a Derived Class}

When an object of a derived class is destroyed:

\begin{enumerate}
    \item The derived class destructor is executed first.
    \item The base class destructor is called automatically.
\end{enumerate}

\begin{codeblock}[language=C++, numbers=none]
DerivedClass::~DerivedClass() {
    // Clean up derived class resources.
    // ~BaseClass() is automatically called after this.
}
\end{codeblock}

\subsubsection{Multiple Inheritance}

C++ allows multiple inheritance, where a class inherits from more than one base class. If multiple base classes have methods with the same name, ambiguity arises, which can be resolved using fully qualified names.

\begin{codeblock}[language=C++, numbers=none]
class B { public: double f() { return 1.0; } };
class C { public: double f() { return 2.0; } };

class D : public B, public C {
public:
    void fun() {
        double x = B::f(); // Resolving ambiguity by specifying base class.
    }
};
\end{codeblock}

Multiple inheritance can lead to the \textit{\textbf{diamond problem}}, where a class indirectly inherits from the same base class through multiple paths. C++ provides\texttt{virtual} inheritance to ensure that only one instance of a shared base class is created.

\begin{codeblock}[language=C++, numbers=none]
class A { /* Base class */ };
class B : virtual public A { /* Inherits A virtually */ };
class C : virtual public A { /* Inherits A virtually */ };
class D : public B, public C { /* D contains only 1 instance of A */ };
\end{codeblock}

\subsection{Dynamic (Runtime) Polymorphism}

\subsubsection{Polymorphism}

Public inheritance enables \textbf{polymorphism}, which allows objects from different classes within a hierarchy to be treated uniformly while still exhibiting type-specific behavior.

\begin{itemize}
    \item A pointer or reference to a derived class \texttt{D} is implicitly convertible to a pointer or reference to a base class \texttt{B} (upcasting).
    \item A method declared as \texttt{virtual} in \texttt{B} can be overridden in \texttt{D} by providing a method with the same signature.
    \item If a base class pointer \texttt{B *b = new D} holds an instance of a derived class, calling a \texttt{virtual} method will execute the derived class's version.
\end{itemize}

\begin{warningblock}[Virtual Methods return type]
    Overridden virtual methods must have the same return type, with the exception that a method returning a pointer (or reference) to a base class may be overridden by a method returning a pointer (or reference) to a derived class.
\end{warningblock}

\subsubsection{\textit{"Is-a"} Relationship}

Polymorphism should be used only when there is a strong \textbf{"is-a"} relationship between the base and derived class. The public interface of the base class must define behaviors common to all members of the hierarchy, ensuring that derived class objects can be safely used in place of base class objects.

\vspace{0.5em}

\begin{center}
\begin{minipage}{0.3\textwidth}
    \centering
    \renewcommand{\arraystretch}{1.2}
    \begin{tabular}{c}
        \textbf{Class Collaboration} \\
        \hline
        has-a \\
    \end{tabular}
\end{minipage}%
\begin{minipage}{0.3\textwidth}
    \centering
    \renewcommand{\arraystretch}{1.2}
    \begin{tabular}{c}
        \textbf{Inheritance} \\
        \hline
        is-a \\
    \end{tabular}
\end{minipage}
\end{center}

\subsection{Function Overriding}

\vspace{-0.5em}

\textbf{Function overriding} is a fundamental feature of polymorphism. It allows a derived class to redefine a function from the base class, ensuring that the most specific implementation is used at runtime.

\vspace{-0.5em}

\begin{codeblock}[language=C++]
class Base {
public:
    virtual void display() {
        std::cout << "Base class." << std::endl;
    }
};

class Derived : public Base {
public:
    void display() override { // 'override' is recommended for clarity.
        std::cout << "Derived class." << std::endl;
    }
};

Base *ptr = new Derived();
ptr->display(); // Calls Derived::display() dynamically.
\end{codeblock}

\vspace{-0.7em}

\begin{tipsblock}[Function Overriding vs. Overloading]
    Function overriding should not be confused with function overloading. Overloading allows multiple functions with the same name but different parameters, whereas overriding replaces an inherited method with a new implementation.
\end{tipsblock}

\vspace{-1em}

\subsubsection{Virtual Methods and Dynamic Dispatch}

\vspace{-0.5em}

The \texttt{virtual} keyword indicates that a method can be overridden by derived classes. When such methods are called, \textbf{dynamic dispatch} selects the appropriate implementation based on the object's actual type during program execution.

\vspace{-0.5em}

\begin{codeblock}[language=C++]
class Polygon {
public:
    virtual double area() { return 0.0; } // Base implementation.
};

class Square : public Polygon {
public:
    double area() override { return side * side; }
private:
    double side;
};

void f(const Polygon &p) {
    const double a = p.area(); // Calls the correct area() dynamically.
}

Square s;
f(s); // Upcasting: 'Square' is treated as 'Polygon'.
\end{codeblock}

\vspace{-0.5em}

\begin{warningblock}[Polymorphism, Pointers, and References]
    Polymorphism applies only when using pointers or references.  
    Passing objects by value leads to slicing, where derived class-specific behavior is lost.
\end{warningblock}

\begin{codeblock}[language=C++, numbers=none]
void f(Polygon p) { // Passed by value (bad practice).
    const double a = p.area(); // Calls Polygon::area(),
                               // not Square::area().
}

Square s;
f(s); // Object slicing: Square is reduced to a Polygon.
\end{codeblock}

\subsubsection{Factory Pattern with Polymorphism}

Polymorphism allows for flexible object creation based on runtime conditions.

\begin{codeblock}[language=C++]
unsigned int n_sides;

std::cout << "Number of sides: ";
std::cin >> n_sides;

Polygon *p;
if (n_sides == 3)
    p = new Triangle{...};
else if (n_sides == 4)
    p = new Square{...};
else {
    // Handle other cases...
}

std::cout << "Area: " << p->area() << std::endl;

delete p; // Always delete allocated memory!
\end{codeblock}

\subsection{Virtual Destructors}

For any class that serves as a base class in a polymorphic hierarchy, implementing a \texttt{virtual} destructor is essential to guarantee proper cleanup of derived class resources.

\begin{codeblock}[language=C++, numbers=none]
class Polygon {
public:
    virtual ~Polygon() {} // Virtual destructor
};
\end{codeblock}

Without a virtual destructor, deleting a derived class object through a base class pointer leads to \textbf{undefined behavior}.

\begin{codeblock}[language=C++, numbers=none]
// Polygon has no virtual destructor.
Polygon *p = new Square();
// ...
delete p; // Calls ~Polygon(), causing potential memory leaks.
\end{codeblock}

\begin{tipsblock}[Compiler Warning]
    Use \plaintt{-Wnon-virtual-dtor} with your compiler to receive warnings when a base class destructor should be virtual.
\end{tipsblock}

\subsubsection{When is a Virtual Destructor Unnecessary?}

A virtual destructor is not required if:
\begin{itemize}
    \item The class is not used polymorphically (i.e., objects are never accessed through base class pointers or references).
    \item The base class does not introduce new members that require cleanup.
\end{itemize}

\subsubsection{Protected and Private Polymorphism}

\textbf{Private polymorphism} is a form of \textbf{private inheritance} where \texttt{virtual} methods are overridden without allowing access to them through a base class pointer. Similarly, \textbf{protected polymorphism} is a form of \textbf{protected inheritance} where \texttt{virtual} methods are overridden, but external calls through a base class pointer are restricted.

However, both private and protected inheritance are not commonly used for polymorphism. \textbf{Polymorphism in C++ is typically associated with public inheritance}, which preserves the \textit{is-a} relationship and ensures that derived classes maintain the interface of the base class.

\begin{observationblock}[When to Use Protected and Private Inheritance]
    \begin{itemize}
        \item Use \textbf{protected inheritance} when you want to limit polymorphism to derived classes.
        \item Use \textbf{private inheritance} when you need implementation reuse but not polymorphism.
    \end{itemize}
\end{observationblock}

\subsection{Selective Inheritance}

Sometimes, you may want to expose only part of the base class interface in a derived class. This can be done using \texttt{using}:

\begin{codeblock}[language=C++, numbers=none]
class Base {
public:
    double fun(int i);
    // Other methods...
};

class Derived : private Base {
public:
    using Base::fun; // Only fun() is exposed publicly.
};
\end{codeblock}

This allows controlled exposure of base class methods while hiding the rest of the interface.

\begin{tipsblock}[Best Practices for Polymorphism]
    \begin{itemize}
        \item Always use \plaintt{override} in derived classes for clarity.
        \item Use \plaintt{virtual} destructors in polymorphic base classes.
        \item Prefer reference or pointer parameters when working with polymorphic objects.
        \item Consider selective inheritance for controlled interface exposure.
    \end{itemize}
\end{tipsblock}

\section{Advanced Polymorphism Concepts}

\subsection{Abstract Classes}

In some cases, a base class represents an abstract concept, and it does not make sense to instantiate concrete objects of that type. Instead, the base class defines the common public interface for a hierarchy but does not fully implement it.

For this purpose, C++ introduces the concept of an \textbf{abstract class}, which is a class that contains at least one \textbf{pure virtual function}. A pure virtual function is declared using the \texttt{= 0} syntax.

\begin{codeblock}[language=C++]
class Shape {
public:
    virtual double area() = 0; // Pure virtual method
};

Shape s; // Illegal! Cannot instantiate an abstract class.
\end{codeblock}

\subsubsection{Characteristics of Abstract Classes}

\begin{itemize}
    \item An \textbf{abstract class} cannot be instantiated. It serves as a blueprint for other classes and enforces a common interface for its derived classes.
    \item Abstract classes contain at least one pure virtual function, which lacks implementation in the base class and is marked with \texttt{= 0}.
    \item They can have regular member functions with implementations and data members.
    \item Derived classes that inherit from an abstract class must implement \textbf{all} pure virtual functions in order to become concrete (instantiable) classes.
    \item Pure virtual functions act as placeholders for functionalities that must be provided by derived classes. They enforce a specific method signature that derived classes must follow.
\end{itemize}

\subsubsection{Implementing an Abstract Class}

When deriving from an abstract class, all pure virtual functions must be implemented in the derived class. The derived class becomes concrete (instantiable) only when all pure virtual functions are implemented. Otherwise, it remains abstract.

\begin{codeblock}[language=C++]
class Triangle : public Shape {
public:
    double area() override { return 0.5 * base * height; }
private:
    double base;
    double height;
};

class Square : public Shape {
public:
    double area() override { return side * side; }
private:
    double side;
};

Triangle t{1.5, 3.0};   // Legal
Square s{0.5};          // Legal
\end{codeblock}

\subsection{The \plaintt{final} and \plaintt{override} Specifiers}

C++ provides two important specifiers to improve the clarity and correctness of inheritance hierarchies: \texttt{final} and \texttt{override}.

\vspace{1em}

The \texttt{final} specifier prevents further overriding of a virtual method or inheritance of a class, ensuring that the implementation remains unchanged in derived classes. When applied to a class, it forbids any further derivation, and when used with a virtual function, it ensures that no subclass can override that function.

\begin{codeblock}[language=C++]
class A {
public:
    virtual void f() final;
    virtual double g(double);
};

class B final : public A {
public:
    void f() override; // Error: f() is final in A.
};

class C : public B // Error: B is final.
{
// ...
};
\end{codeblock}

The \texttt{override} specifier ensures that the method in the derived class correctly overrides the base class method. By explicitly stating this intent, any signature mismatches will trigger a compile-time error, thereby enhancing code safety and clarity.

\begin{codeblock}[language=C++]
class A {
    virtual void f();
    void g();
};

class B : public A {
    void f() const override; // Error: Signature does not match A::f().
    void f() override; // OK: Correctly overrides A::f().
    void g() override; // Error: g() is not virtual in A.
};
\end{codeblock}

\begin{tipsblock}[Compiler Tip]
Although \plaintt{override} is not mandatory, it is strongly recommended to catch potential errors during compilation; moreover it improves code safety and clarity.

The compiler option \plaintt{-Wsuggest-override} can be used to generate warnings when the \plaintt{override} specifier is missing.
\end{tipsblock}

\subsection{Type Casting in Polymorphic Hierarchies}

In polymorphic class hierarchies, it is often necessary to determine an object's actual type at runtime or safely convert between base and derived class pointers. C++ provides mechanisms such as \textbf{Run-Time Type Information (RTTI)} and \texttt{dynamic\_cast} to achieve this.

\subsubsection{Run-Time Type Identification (RTTI) and \texttt{typeid}}

RTTI allows the program to determine the actual type of an object at runtime, which is particularly useful in polymorphic hierarchies.
The \texttt{typeid} operator returns a type descriptor that can be inspected or compared.

\begin{codeblock}[language=C++]
#include <typeinfo>

class Base {
public:
    virtual void print() { std::cout << "Base class" << std::endl; }
};

class Derived : public Base {
public:
    void print() override { std::cout << "Derived class" << std::endl; }
};

// in main()
Base base;
Derived derived;
std::cout << "Type of base: " << typeid(base).name() << std::endl;
// Output: Type of base: 4Base
std::cout << "Type of derived: " << typeid(derived).name() << std::endl;
// Output: Type of derived: 7Derived
\end{codeblock}

Since \texttt{typeid} queries the actual type of an object, it requires at least one \texttt{virtual} function in the base class. Otherwise, it only provides the static type determined at compile time.

\subsubsection{Type Checking with \texttt{dynamic\_cast}}

The \texttt{dynamic\_cast} operator ensures safe downcasting in polymorphic hierarchies. It performs a runtime check to verify whether a base class pointer can be converted to a pointer of a derived class.

\begin{codeblock}[language=C++]
double compute_area(const Shape& p) {
    auto ptr = dynamic_cast<const Square*>(&p);
    if (ptr != nullptr) {
        return ptr->get_side() * ptr->get_side(); // Safe only if p is a Square.
    } else {
        return p.area();
    }
}
\end{codeblock}

If the conversion is not valid:
\begin{itemize}
    \item For pointer conversions, \texttt{dynamic\_cast} returns \texttt{nullptr} to signal a failed cast.
    \item For reference conversions, a failed \texttt{dynamic\_cast} throws a \texttt{std::bad\_cast} exception; ensure you handle this case using a \texttt{try-catch} block.
\end{itemize}

\subsection{Aggregation vs. Composition with Polymorphic Objects}

When a class aggregates a polymorphic object, a key design decision is whether it should take ownership of the object's lifetime.

\begin{codeblock}[language=C++]
class Prism {
public:
    // 1) Aggregation: Takes an external object, does not manage its lifetime.
    Prism(Shape* s) : shape{s} {}

    // 2) Composition: Creates and manages the object's lifetime.
    void init_as_square(double side) {
        poly_ptr = new Square{side};
    }
    ~Prism() { delete poly_ptr; }

private:
    Shape* shape;  // Aggregation (does not own object)
    Shape* poly_ptr = nullptr; // Composition (owns object)
};
\end{codeblock}

\subsection{Best Practices in Polymorphic Hierarchies}

\begin{tipsblock}[Guidelines for Effective Use of Polymorphism]
    \begin{itemize}
        \item \textbf{Follow the Liskov Substitution Principle (LSP)}: Derived classes must be interchangeable with their base class without altering program behavior.
        \item \textbf{Use virtual destructors}: If a class is intended to be used polymorphically, its destructor should be declared as \plaintt{virtual}.
        \item \textbf{Prefer composition over inheritance}: Avoid deep inheritance chains; favor composition when possible.
        \item \textbf{Avoid excessive downcasting}: Rely on virtual functions instead of frequent use of \plaintt{dynamic\_cast}.
        \item \textbf{Encapsulation}: Keep base class members \plaintt{protected} or \plaintt{private} and provide controlled access through public methods.
    \end{itemize}
\end{tipsblock}
